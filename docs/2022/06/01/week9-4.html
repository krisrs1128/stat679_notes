<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content=""><title>Graph Representations | Statistical Data Visualization</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/r.min.js"></script>
<script>hljs.highlightAll();</script>

  <meta name="keywords" content="">
  <meta name="description" content=""><link rel="stylesheet" href="/stat679_notes/assets/main.css?v=0.3.3" />
<script src="/stat679_notes/assets/main.js?v=0.3.3" defer></script><link rel="stylesheet" href="/stat679_notes/assets/css/tomorrow.css" />
<script src="/stat679_notes/assets/js/highlight.js"></script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src="https://unpkg.com/mermaid@7.1.0/dist/mermaid.min.js" defer></script></head>
<body class="body-post">
    <a href="/stat679_notes/" class="logo"><h1>Statistical Data Visualization</h1>
</a><main class="post__wrapper"><div class="post__top_navs clearfix">
    <nav class="post__archive_path"><a href="" id="archiveBtn">
        <div class="post__archive_icon">
          <svg width="40" height="40">
            <circle class="circle-progress" r="18" cy="20" cx="20"  stroke-linejoin="round" stroke-linecap="round" />
          </svg>
          <span class="post__archive_icon"></span>
        </div>
        Statistical Data Visualization
      </a>
    </nav>
  </div>
  <article class="post">
    <header class="post__header">
      <h1 class="post__title">Graph Representations</h1>
      <div class="post__meta">
        <time>2022-06-01 00:00</time>
      </div>
    </header>
    <div class="post__content content">
      <p><em>Visual marks for general graphs</em></p>

<ol>
  <li>
    <p>In these notes, we’ll discuss how to implement a few basic types of
general graph visualizations using R and javascript. For R, we’ll
focus on ggraph, and for javascript, we’ll use D3’s graph layout
functions.</p>
  </li>
  <li>
    <p>The goal of the ggraph package is to provide ggplot2-like design
iteration for graph structured (rather than tabular) data. Like
ggplot2, visualizations are built by composing layers for separate
visual marks. Scale and labeling functions are also available to
customize the appearance of these marks.</p>
  </li>
  <li>
    <p>For example, to build a node-link visualization, we can use the
<code class="language-plaintext highlighter-rouge">geom_node</code> and <code class="language-plaintext highlighter-rouge">geom_edge_link</code> layers. Note that <code class="language-plaintext highlighter-rouge">ggraph</code> expects
a <code class="language-plaintext highlighter-rouge">tbl_graph</code> as input, not simply a <code class="language-plaintext highlighter-rouge">data.frame</code>.</p>
  </li>
  <li>
    <p>Attributes of nodes and edges can be encoded using size (node radius
or edge width) or color. The node-link representation is especially
effective for the task of following paths. It’s an intuitive
visualization for examining the local neighborhood of one node or
describing the shortest path between two nodes.</p>
  </li>
  <li>
    <p>Let’s make the analogous graph in D3. We first read in the JSON’s
associated the nodes and edges.</p>

    <p>We can then use d3’s force-directed layout algorithm to compute a
layout of the nodes given a connectivity structure. The algorithm
simulates forces that try to repel nodes from each other, while
tension on the edges keeps connected ones close to one another. It
is just one of many layout algorithms, some of which we’ll review in
the next lecture.</p>
  </li>
  <li>
    <p>The key drawback of node-link diagrams is that they do not scale
well to networks with a large number of nodes or with a large number
of edges per node. The nodes and edges begin to overlap too much,
and the result looks like a “hairball.”</p>
  </li>
  <li>
    <p>In this case, it’s often useful to try filtering or aggregating
nodes. For example, aggregation works by replacing the original
nodes with metanodes representing entire clusters. This is
especially powerful if the degree of filtering or aggregation can be
adjusted interactively — we’ll explore this strategy when we study
interactivity for graph visualization.</p>
  </li>
  <li>
    <p>Alternatively, another way to solve the hairball problem is to use
an adjacency matrix visualization instead. The adjacency matrix of a
graph is the matrix with a 1 in entry ij if nodes i and j are linked
by an edge and 0 otherwise. It has one row and one column for every
node in the graph. Visually, these 1’s and 0’s can be encoded as a
black and white squares.</p>
  </li>
  <li>
    <p>The example below shows the adjacency matrix associated with the
high-school student friendship network from last lecture. We use the
“matrix” layout with a <code class="language-plaintext highlighter-rouge">geom_edge_tile</code> layer to draw adjacency
matrices in ggraph.</p>
  </li>
  <li>
    <p>In D3, an adjacency matrix visualization is simply a collection of
appropriately placed SVG <code class="language-plaintext highlighter-rouge">rect</code>s.</p>
  </li>
  <li>
    <p>Note that we have to associate each node with both an x and a y
coordinate and that the visualization is dependent on the choice of
ordering. There are a variety of algorithms available for ordering
nodes in an adjacency matrix, but implementing this manually can be
tedious. Fortunately, there is a javascript package (reorder.js)
that specifically supports these algorithms.</p>
  </li>
  <li>
    <p>The key advantage of visualization using adjacency matrices is that
they can scale to large and dense networks. It’s possible to
perceive structure even when the squares are quite small, and there
is no risk of edges overlapping with one another.</p>
  </li>
  <li>
    <p>The key disadvantage of adjacency matrix visualization is that it’s
challenging to make sense of the local topology around a node.
Finding the « friends of friends » of a node requires effort.
Another issue is that different orderings of rows and columns can
have a dramatic effect on the structure that’s visible.</p>
  </li>
</ol>

    </div>
  </article></main><script>hljs.initHighlightingOnLoad();</script><footer class="site-footer">
  © 2022<a href="/stat679_notes/">Statistical Data Visualization</a>. Theme<a href="https://github.com/erlzhang/jekyll-theme-persephone" target="_blank">Persephone</a>
</footer>

  </body>
</html>
