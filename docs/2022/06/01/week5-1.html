<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content=""><title>Enter, Update, Exit | Statistical Data Visualization</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/r.min.js"></script>
<script>hljs.highlightAll();</script>

  <meta name="keywords" content="">
  <meta name="description" content=""><link rel="stylesheet" href="/stat679_notes/assets/main.css?v=0.3.3" />
<script src="/stat679_notes/assets/main.js?v=0.3.3" defer></script><link rel="stylesheet" href="/stat679_notes/assets/css/tomorrow.css" />
<script src="/stat679_notes/assets/js/highlight.js"></script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src="https://unpkg.com/mermaid@7.1.0/dist/mermaid.min.js" defer></script></head>
<body class="body-post">
    <a href="/stat679_notes/" class="logo"><h1>Statistical Data Visualization</h1>
</a><main class="post__wrapper"><div class="post__top_navs clearfix">
    <nav class="post__archive_path"><a href="" id="archiveBtn">
        <div class="post__archive_icon">
          <svg width="40" height="40">
            <circle class="circle-progress" r="18" cy="20" cx="20"  stroke-linejoin="round" stroke-linecap="round" />
          </svg>
          <span class="post__archive_icon"></span>
        </div>
        Statistical Data Visualization
      </a>
    </nav>
  </div>
  <article class="post">
    <header class="post__header">
      <h1 class="post__title">Enter, Update, Exit</h1>
      <div class="post__meta">
        <time>2022-06-01 00:00</time>
      </div>
    </header>
    <div class="post__content content">
      <p><em>Modifying the DOM with data</em></p>

<ol>
  <li>
    <p>In interactive visualization, we often need to add or remove elements from
the previous static view. Alternatively, we may choose to modify the visual
encodings in an updated view. Both types of tasks can be accomplished using d3’s
enter-exit-update pattern. This pattern is so common that it is often called
d3’s “general update pattern.”</p>
  </li>
  <li>
    <p>The pattern operates on d3 selections that are already bound to data stored
in an array. If we bind a new dataset to the same selection, there are two types
of changes we need to account for,</p>

    <ul>
      <li>The number of array elements may no longer match the number of HTML tags.</li>
      <li>The values stored in each array element might have changed, and we may want
 visual encodings to update accordingly.</li>
    </ul>
  </li>
  <li>
    <p>For the first issue, there are two functions that are helpful for resolving
the discrepancy,</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">.enter()</code> refers to the array elements that don’t have corresponding HTML
tags. It is most often used to append new SVG objects to the original
selection.</li>
      <li><code class="language-plaintext highlighter-rouge">.exit()</code> refers to HTML tags that no longer have associated array elements.
It is most often used to remove tags that are no longer needed (because the
data has become smaller).</li>
    </ul>
  </li>
  <li>
    <p>Let’s tinker with these ideas in a more hands on example. First, I will bind
a sequence of 10 numbers to a selection of circles and then append them to a
parent SVG. The circles’ x-coordinates are determined by the number in the
array. So far, there are no enters / exits / updates to consider.</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	let circles = d3.range(10);

	d3.select("svg")
	  .selectAll("circle")
	  .data(circles).enter()
	  .append("circle")
	  .attrs({
  		r: 10,
  		cx: d =&gt; (d + 1) * 50,
  		cy: 100,
	  })
</code></pre></div></div>

<ol>
  <li>Now, suppose we add three additional elements to the circles array.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> circles = circles.concat([10, 11, 12])
</code></pre></div>    </div>
    <p>How can we add associated elements to the page without having to redraw
 everything? We can rebind the data and use <code class="language-plaintext highlighter-rouge">.enter()</code>. We’ve drawn them in a
 different color, so you can see that it’s not just redrawing all the circles.</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	d3.select("svg")
	  .selectAll("circle")
	  .data(circles).enter()
	  .append("circle")
	  .attrs({
  		r: 10,
  		cx: d =&gt; (d + 1) * 50,
  		cy: 100,
  		fill: "red"
	  })
</code></pre></div></div>

<ol>
  <li>Similar logic works for exits. Suppose that instead of adding three elements,
we had removed three.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> circles = circles.slice(3)
</code></pre></div>    </div>

    <p>We can refer to the tags that no longer have data bound to them using
 <code class="language-plaintext highlighter-rouge">.exit()</code>. The block below shades those points in blue.</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> d3.select("svg")
   .selectAll("circle")
   .data(circles).exit()
   .attr("fill", "blue")
</code></pre></div>    </div>
  </li>
  <li>
    <p>Notice that the logic of <code class="language-plaintext highlighter-rouge">enter</code> and <code class="language-plaintext highlighter-rouge">exit</code> is tied closely with the indices
of the arrays given to <code class="language-plaintext highlighter-rouge">.data()</code>. These functions simply check the lengths of
arrays across data binds, always associating the first tag on the page with the
first element in the array, the second tag with the second element, etc. We’ll
see alternative ways to bind that refer to the actual values in the arrays,
rather than simply their index.</p>
  </li>
  <li>The enter and exit patterns are commonly coupled with transitions, to allow
for smoother fade in / out. For example, if we want to smoothly fade in the
entered red circles, we first append them with radius 0 and then increase their
size following a transition.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> circles = circles.concat([10, 11, 12])
 d3.select("svg")
   .selectAll("circle")
   .data(circles).enter()
   .append("circle")
   .attrs({                  // append circles at
  		cx: d =&gt; (d + 1) * 50,  // right position, but
  		cy: 100,                // invisibly
  		r: 0,
  		fill: "red"
   })
   .transition()
   .duration(2000)
   .attr("r", 10)            // grow the circles
</code></pre></div>    </div>
  </li>
  <li>Alternatively, if we want to gradually shrink the circles before they
disappear, we can change their radius attribute and then call <code class="language-plaintext highlighter-rouge">.remove()</code> to
remove the tags from the DOM.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> circles = circles.slice(3)
 d3.select("svg")
   .selectAll("circle")
   .data(circles).exit()
   .transition()
   .duration(4000)
   .attr("r", 0)
   .remove()
</code></pre></div>    </div>
  </li>
  <li>What if want to change attributes for all tags, and not just those that were
entered / exited? There are several strategies. The simplest is to reselect all
matching items. For example, if we want all circles to be red, not just those
that were entered, we could use
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>circles = circles.concat([10, 11, 12])
d3.select("svg")
  .selectAll("circle")
  .data(circles).enter()
  .append("circle")
  .attrs({
  		cx: d =&gt; (d + 1) * 50,
  		cy: 100,
  		r: 10,
  		fill: "red"
  })

d3.select("svg")
  .selectAll("circle")
  .attrs({ fill: "red" })
</code></pre></div>    </div>
    <p>but this is inefficient, because it will change attributes even for the entered elements, which we already know have the correct attributes. An alternative is to store the “update” selection (those that were present in both data binds) in a variable and then handle the enter and update changes separately.</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let circ = d3.select("svg")
  .selectAll("circle")
  .data(circles)

circ.enter()
  .append("circle")
  .attrs({
  		cx: d =&gt; (d + 1) * 50,
  		cy: 100,
  		r: 10,
  		fill: "red"
  })

circ.attrs({ fill: "red" })
</code></pre></div>    </div>
  </li>
</ol>

    </div>
  </article></main><script>hljs.initHighlightingOnLoad();</script><footer class="site-footer">
  © 2022<a href="/stat679_notes/">Statistical Data Visualization</a>. Theme<a href="https://github.com/erlzhang/jekyll-theme-persephone" target="_blank">Persephone</a>
</footer>

  </body>
</html>
