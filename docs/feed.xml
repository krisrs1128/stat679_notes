<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/stat679_notes/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/stat679_notes/" rel="alternate" type="text/html" /><updated>2022-07-26T18:42:45-05:00</updated><id>http://localhost:4000/stat679_notes/feed.xml</id><title type="html">Statistical Data Visualization</title><subtitle>These are notes from STAT 679 (Fall 2022) at UW Madison.</subtitle><entry><title type="html">Graph Representations</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week9-4.html" rel="alternate" type="text/html" title="Graph Representations" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week9-4</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week9-4.html"><![CDATA[<p><em>Visual marks for general graphs</em></p>

<ol>
  <li>
    <p>In these notes, we’ll discuss how to implement a few basic types of
general graph visualizations using R and javascript. For R, we’ll
focus on ggraph, and for javascript, we’ll use D3’s graph layout
functions.</p>
  </li>
  <li>
    <p>The goal of the ggraph package is to provide ggplot2-like design
iteration for graph structured (rather than tabular) data. Like
ggplot2, visualizations are built by composing layers for separate
visual marks. Scale and labeling functions are also available to
customize the appearance of these marks.</p>
  </li>
  <li>
    <p>For example, to build a node-link visualization, we can use the
<code class="language-plaintext highlighter-rouge">geom_node</code> and <code class="language-plaintext highlighter-rouge">geom_edge_link</code> layers. Note that <code class="language-plaintext highlighter-rouge">ggraph</code> expects
a <code class="language-plaintext highlighter-rouge">tbl_graph</code> as input, not simply a <code class="language-plaintext highlighter-rouge">data.frame</code>.</p>
  </li>
  <li>
    <p>Attributes of nodes and edges can be encoded using size (node radius
or edge width) or color. The node-link representation is especially
effective for the task of following paths. It’s an intuitive
visualization for examining the local neighborhood of one node or
describing the shortest path between two nodes.</p>
  </li>
  <li>
    <p>Let’s make the analogous graph in D3. We first read in the JSON’s
associated the nodes and edges.</p>

    <p>We can then use d3’s force-directed layout algorithm to compute a
layout of the nodes given a connectivity structure. The algorithm
simulates forces that try to repel nodes from each other, while
tension on the edges keeps connected ones close to one another. It
is just one of many layout algorithms, some of which we’ll review in
the next lecture.</p>
  </li>
  <li>
    <p>The key drawback of node-link diagrams is that they do not scale
well to networks with a large number of nodes or with a large number
of edges per node. The nodes and edges begin to overlap too much,
and the result looks like a “hairball.”</p>
  </li>
  <li>
    <p>In this case, it’s often useful to try filtering or aggregating
nodes. For example, aggregation works by replacing the original
nodes with metanodes representing entire clusters. This is
especially powerful if the degree of filtering or aggregation can be
adjusted interactively — we’ll explore this strategy when we study
interactivity for graph visualization.</p>
  </li>
  <li>
    <p>Alternatively, another way to solve the hairball problem is to use
an adjacency matrix visualization instead. The adjacency matrix of a
graph is the matrix with a 1 in entry ij if nodes i and j are linked
by an edge and 0 otherwise. It has one row and one column for every
node in the graph. Visually, these 1’s and 0’s can be encoded as a
black and white squares.</p>
  </li>
  <li>
    <p>The example below shows the adjacency matrix associated with the
high-school student friendship network from last lecture. We use the
“matrix” layout with a <code class="language-plaintext highlighter-rouge">geom_edge_tile</code> layer to draw adjacency
matrices in ggraph.</p>
  </li>
  <li>
    <p>In D3, an adjacency matrix visualization is simply a collection of
appropriately placed SVG <code class="language-plaintext highlighter-rouge">rect</code>s.</p>
  </li>
  <li>
    <p>Note that we have to associate each node with both an x and a y
coordinate and that the visualization is dependent on the choice of
ordering. There are a variety of algorithms available for ordering
nodes in an adjacency matrix, but implementing this manually can be
tedious. Fortunately, there is a javascript package (reorder.js)
that specifically supports these algorithms.</p>
  </li>
  <li>
    <p>The key advantage of visualization using adjacency matrices is that
they can scale to large and dense networks. It’s possible to
perceive structure even when the squares are quite small, and there
is no risk of edges overlapping with one another.</p>
  </li>
  <li>
    <p>The key disadvantage of adjacency matrix visualization is that it’s
challenging to make sense of the local topology around a node.
Finding the « friends of friends » of a node requires effort.
Another issue is that different orderings of rows and columns can
have a dramatic effect on the structure that’s visible.</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Visual marks for general graphs]]></summary></entry><entry><title type="html">Visual Encodings</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-2.html" rel="alternate" type="text/html" title="Visual Encodings" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-2.html"><![CDATA[<p><em>Design principles from the grammar of graphics.</em></p>

<ol>
  <li>
    <p>Visualizations link abstract data with the physical, geometric
marks,</p>

    <ul>
      <li>Each observation (row) within a dataset corresponds to a
geometric mark in a visualization.</li>
      <li>Important attributes (columns) of an observation within a
dataset can be encoded by properties of visual marks.</li>
    </ul>

    <p>This encoding of rows as marks and columns as properties of the
marks is illustrated in the toy diagram below.</p>

    <p><img src="/stat679_notes/assets/week1-1/encoding_illustration.png" alt="" /></p>
  </li>
  <li>
    <p>A good visualization makes it easy to visually compare the relevant
attributes across observations. A challenge is that there are often
many possible marks and encodings for any given comparison. It’s
also difficult to know which comparisons are actually of interest.
For these reasons, we’re going to want to build up a vocabulary of
marks and encodings.</p>

    <p><img src="/stat679_notes//assets/week1-1/example_encodings.png" alt="" /></p>
  </li>
  <li>
    <p>To identify good encodings, it can often help to first what the
types of each field are.</p>

    <ul>
      <li>Nominal: These are fields that allow identity comparisons
between observations (is <em>A</em> = <em>B</em>?), but don’t come with any
notion of order.
        <ul>
          <li>City region, country name, movie genres, file types, …</li>
        </ul>
      </li>
      <li>Ordinal: These are fields that allow ordering comparisons
between observations (is <em>A</em> &gt; <em>B</em>?), but don’t let you
quantify the degree of difference.
        <ul>
          <li>Shirt size, sports team rankings, order of appearance of
characters on TV show</li>
        </ul>
      </li>
      <li>Quantitative: These are field types that let you make distance
comparisons between observations. For interval data, absolute
comparisons can be made (<em>A</em> − <em>B</em>), while for ratio data, only
relative ones ($\frac{A}{B}$) are possible.
        <ul>
          <li>Temperature, stock price, number of drinks sold in a coffee
shop per day</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>This is not an exhaustive list, and there are subtleties,</p>

    <ul>
      <li>The same field could be treated as nominal, ordinal, or
quantitative depending on the context. Age could be nominal
(underage or overage), ordinal (gen Z, millenial, …), or
quantitative.</li>
      <li>A given field might be thought of hierarchically. There might be
interesting patterns at the city, county, or region level – what
seems like a single column can become the source for multiple
derived fields.</li>
      <li>Even though temporal fields can be thought of as quantitative,
they come with their own conventions. For example, the hour -
week - month hierarchy is a natural one for temporal data.</li>
    </ul>
  </li>
  <li>
    <p>It’s worth highlighting that, even if a particular encoding <em>could</em>
be used for a given data type, different encodings have different
effectiveness. When trying to encoding several data fields at once,
a choice of one encoding over another will implicitly prioritize
certain comparisons over others.</p>

    <p>For example, in the figure below (Figure 5.8
<a href="https://search.library.wisc.edu/catalog/9911196629502121">here</a>),
the same two numbers are encoded using many different visual
properties – position on a shared <em>y</em>-axis, position on distinct
<em>y</em>-axes, etc. – and study participants were asked to gauge the
difference in the numbers. People were best at comparing positions
on a common scale, and worst at distinguishing differences in areas.</p>

    <p><img src="/stat679_notes/assets/week1-1/encoding_effectiveness.png" alt="" /></p>
  </li>
  <li>
    <p>Here is a similar example. In the left four panels, a nominal field
is encoded using color (left two) and shape (middle two). The red
circles are easiest to find in the left two. In the right two
panels, two nominal fields are encoded, using both shape and color.
It’s much harder to find the red circle – you have to scan over the
entire image to find it, which you didn’t have to do at all for the
first two panels.</p>

    <p><img src="/stat679_notes/assets/week1-1/encoding_effectiveness_2.png" alt="" /></p>
  </li>
  <li>
    <p>Implicit in this discussion is that there is never any “perfect”
visualization for a given dataset – the quality of a visualization
is a function of its intended purpose. What comparisons do you want
to facilitate? The choice of encoding will strongly affect the types
of comparisons that are easy to perform.</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Design principles from the grammar of graphics.]]></summary></entry><entry><title type="html">A Vocabulary of Marks</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-3.html" rel="alternate" type="text/html" title="A Vocabulary of Marks" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-3.html"><![CDATA[<p><em>Encoding options in ggplot2</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(scales)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>The choice of encodings influences (1) the types of comparisons that
a visualization suggests and (2) the accuracy of the conclusions
that readers leave with. With this in mind, it’s in our best
interest to build a rich vocabulary of potential visual encodings.
The more kinds of marks and encodings that are at your fingertips,
the better your chances are that you’ll arrive at a configuration
that helps you achieve your purpose.</p>
  </li>
  <li>
    <p><strong>Point marks</strong> can encode data fields using their x and y
positions, color, size, and shape. Below, each mark is a country,
and we’re using shape and the y position to distinguish between
country clusters.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gapminder &lt;- read_csv("https://uwmadison.box.com/shared/static/dyz0qohqvgake2ghm4ngupbltkzpqb7t.csv", col_types = cols()) %&gt;%
  mutate(cluster = as.factor(cluster)) # specify that cluster is nominal
gap2000 &lt;- gapminder %&gt;%
  filter(year == 2000) # keep only year 2000
    ggplot(gap2000) +
      geom_point(aes(x = fertility, y = cluster, shape = cluster))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Bar marks</strong> Bar marks let us associate a continuous field with a
nominal one.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(gap2000) +
  geom_col(aes(country, pop))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-4-1.png" alt="" /></p>
  </li>
  <li>
    <p>This plot can be improved. The grid lines and tick marks associated
with each bar are distracting and the axis labels are all running
over one another. We resolve this by changing the theme and turning
the bars on their side[1]</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(gap2000) +
      geom_col(aes(pop, country)) +
      theme(
        panel.grid.major.y = element_blank(),
        axis.ticks = element_blank() # remove tick marks
      )
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>To make comparisons between countries with similar populations
easier, we can order them by population (alphabetical ordering is
not that meaningful). To compare clusters, we can color in the bars.</p>
  </li>
  <li>
    <p>We’ve been spending a lot of time on this plot. This is because I
want to emphasize that a visualization is not just something we can
get just by memorizing some magic (programming) incantation.
Instead, it is something worth critically engaging with and
refining, in a similar way that we would refine an essay or speech.
Philosophy aside, there are still a few points that need to be
improved in this figure,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> * The axis titles are not meaningful.
 * There is a strange gap between the left hand edge of the plot and the start of the bars.
 * I would also prefer if the bars were exactly touching one another, without the small vertical gap.
 * The scientific notation for population size is unnecessarily technical.
 * The color scheme is a bit boring^[.
</code></pre></div>    </div>
  </li>
  <li>
    <p>I’ve addressed each issue in the block below. Can you tell which
piece of code makes which change? Try removing different components
to verify your guesses.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cols &lt;- c("#80BFA2", "#7EB6D9", "#3E428C", "#D98BB6", "#BF2E21", "#F23A29")
    ggplot(gap2000) +
       geom_col(
         aes(pop, reorder(country, pop), fill = cluster),
         width = 1
       ) +
       scale_x_continuous(label = label_number_si(), expand = c(0, 0, 0.1, 0.1)) +
       scale_fill_manual(values = cols) +
       labs(x = "Population", y = "Country", fill = "Country Group", color = "Country Group") +
       theme(
         axis.ticks = element_blank(),
         panel.grid.major.y = element_blank()
       )
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-6-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Segment marks</strong>. In the plot above, each bar is anchored at 0.
Instead, we could have each bar encode two continuous values, a left
and right. To illustrate, let’s compare the minimum and maximimum
life expectancies within each country cluster. We’ll need to create
a new data.frame with just the summary information. For this, we
<code class="language-plaintext highlighter-rouge">group_by</code> each cluster, so that a summarise call finds the minimum
and maximum life expectancies restricted to each cluster.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># find summary statistics
life_ranges &lt;- gap2000 %&gt;%
  group_by(cluster) %&gt;%
  summarise(
    min_life = min(life_expect),
    max_life = max(life_expect)
  )

ggplot(life_ranges) +
  geom_segment(
    aes(min_life, reorder(cluster, max_life), xend = max_life, yend = cluster, col = cluster),
    size = 5,
  ) +
  scale_color_manual(values = cols) +
  labs(x = "Minimum and Maximum Expected Span", col = "Country Group", y = "Country Group") +
  xlim(0, 85) # otherwise would only range from 42 to 82
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-7-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Line marks</strong> are useful for comparing changes. Our eyes naturally
focus on rates of change when we see lines. Below, we’ll plot the
fertility over time, colored in by country cluster. The group
argument is useful for ensuring each country gets its own line; if
we removed it, ggplot2 would become confused by the fact that the
same x (year) values are associated with multiple y’s (fertility
rates).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(gapminder) +
      geom_line(
        aes(year, fertility, col = cluster, group = country),
          alpha = 0.7, size = 0.9
      ) +
      scale_x_continuous(expand = c(0, 0)) +  # same trick of removing gap
      scale_color_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
  <li>
    <p>Area marks have a flavor of both bar and line marks. The filled area
supports absolute comparisons, while the changes in shape suggest
derivatives.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_sums &lt;- gapminder %&gt;%
  group_by(year, cluster) %&gt;%
  summarise(total_pop = sum(pop))

ggplot(population_sums) +
  geom_area(aes(year, total_pop, fill = cluster)) +
  scale_y_continuous(expand = c(0, 0, .1, .1), label = label_number(cut_short_scale())) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-9-1.png" alt="" /></p>
  </li>
  <li>
    <p>Just like in bar marks, we don’t necessarily need to anchor the
y-axis at 0. For example, here the bottom and top of each area mark
is given by the 30% and 70% quantiles of population within each
country cluster.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_ranges &lt;- gapminder %&gt;%
  group_by(year, cluster) %&gt;%
  summarise(min_pop = quantile(pop, 0.3), max_pop = quantile(pop, 0.7))

ggplot(population_ranges) +
  geom_ribbon(
    aes(x = year, ymin = min_pop, ymax = max_pop, fill = cluster),
    alpha = 0.8
  ) +
  scale_y_continuous(expand = c(0, 0, .1, .1), label = label_number_si()) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-10-1.png" alt="" /></p>
  </li>
</ol>

<p>[1] An alternative is to turn rotate the labels by 90 degrees. I prefer
to turn the whole plot this, because this way, readers don’t have to
tilt their heads to read the country names.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Encoding options in ggplot2]]></summary></entry><entry><title type="html">Small Multiples and Faceting</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-4.html" rel="alternate" type="text/html" title="Small Multiples and Faceting" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-4</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-4.html"><![CDATA[<p><em>Increased information density through faceting</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(dslabs)
library(tidyverse)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>It might seem like we’re limited with the total number of variables
we can display at a time. While there are many types of encodings we
could in theory use, only a few them are very effective, and they
can interfere with one another.</p>
  </li>
  <li>
    <p>Not all is lost, though! A very useful idea for visualizing
high-dimensional data is the idea of small multiples. It turns out
that our eyes are pretty good at making sense of many small plots,
as long as there is some shared structure across the plots.</p>

    <p><img src="https://krisrs1128.github.io/stat479/posts/2021-01-20-week2-1/assets/sparklines.png" alt="" /></p>
  </li>
  <li>
    <p>In ggplot2, we can implement this idea using the <code class="language-plaintext highlighter-rouge">facet_wrap</code> and
<code class="language-plaintext highlighter-rouge">facet_grid</code> commands. We specify the column in the data.frame along
which we want to generate comparable small multiples.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>years &lt;- c(1962, 1980, 1990, 2000, 2012)
continents &lt;- c("Europe", "Asia")
gapminder_subset &lt;- gapminder %&gt;%
  filter(year %in% years, continent %in% continents)

ggplot(
    gapminder_subset, 
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(. ~ year) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p>In facet grid, you specify whether you want the plot to be repeated
across rows or columns, depending on whether you put the variable
before or after the tilde.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder_subset, 
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(year ~ .) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-4-1.png" alt="" /></p>
  </li>
  <li>
    <p>You can also facet by more than one variable at a time, specifying
which variables should go in rows and which should go in columns
again using the tilde.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder %&gt;% filter(year %in% years),
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(year ~ continent) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>Sometimes, you just want to see the display repeated over groups,
but you don’t really need them to all appear in the same row or
column. In this case, you can use <code class="language-plaintext highlighter-rouge">facet_wrap</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder %&gt;% filter(year %in% years),
    aes(x = fertility, y = life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_wrap(~ year)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-6-1.png" alt="" /></p>
  </li>
  <li>
    <p>Just to illustrate, faceting makes sense for datasets other than
scatterplots. This example also shows that faceting will apply to
multiple geom layers at once. The dataset below shows the abundances
of five different bacteria across three different subjects over
time, as they were subjected to antibiotics. The data were the basis
for [this study](&lt;)&gt;.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>antibiotic &lt;- read_csv("https://uwmadison.box.com/shared/static/5jmd9pku62291ek20lioevsw1c588ahx.csv")
head(antibiotic)

## # A tibble: 6 × 7
##   species  sample value ind    time svalue antibiotic     
##   &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          
## 1 Unc05qi6 D1         0 D         1   NA   Antibiotic-free
## 2 Unc05qi6 D2         0 D         2   NA   Antibiotic-free
## 3 Unc05qi6 D3         0 D         3    0   Antibiotic-free
## 4 Unc05qi6 D4         0 D         4    0   Antibiotic-free
## 5 Unc05qi6 D5         0 D         5    0   Antibiotic-free
## 6 Unc05qi6 D6         0 D         6    0.2 Antibiotic-free
</code></pre></div>    </div>
  </li>
  <li>
    <p>I have also separately computed running averages for each of the
variables – this is in the <code class="language-plaintext highlighter-rouge">svalue</code> column.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(antibiotic, aes(x = time)) +
      geom_line(aes(y = svalue), size = 1.2) +
      geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
      facet_grid(species ~ ind) +
      scale_color_brewer(palette = "Set2") +
      theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
  <li>
    <p>It seems like some of the species are much more abundant than
others. In this situation, it might make sense to rescale the
y-axis. Though, this is always a risky decision – people might
easily misinterpret the plot and conclude that the different species
all have the same abundances. Nonetheless, it can’t hurt to try,
using the scale argument to <code class="language-plaintext highlighter-rouge">facet_grid</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(antibiotic, aes(x = time)) +
      geom_line(aes(y = svalue), size = 1.2) +
      geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
      facet_grid(species ~ ind, scale = "free_y") +
      scale_color_brewer(palette = "Set2") +
      theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-9-1.png" alt="" /></p>
  </li>
  <li>
    <p>Unlike the years example, the facets don’t automatically come with
their own natural order. We can define an order based on the average
value of the responses over the course of the survey.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(antibiotic, aes(x = time)) +
  geom_line(aes(y = svalue), size = 1.2) +
  geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
  facet_grid(reorder(species, value, mean) ~ ind, scale = "free_y") +
  scale_color_brewer(palette = "Set2") +
  theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-10-1.png" alt="" /></p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Increased information density through faceting]]></summary></entry><entry><title type="html">Structured Graphs</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week10-1.html" rel="alternate" type="text/html" title="Structured Graphs" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week10-1</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week10-1.html"><![CDATA[<p><em>Representing known structure in graphs</em></p>

<ol>
  <li>
    <p>Graph layouts can often benefit from additional information known
about the structure of the graph or purpose of the visualization.
These notes describe a few of the situations that arise most
frequently in practice.</p>
  </li>
  <li>
    <p>When there is no additional structure / specific purpose, a
reasonable default for node-link diagrams uses force-directed
layout. In this layout, we think of nodes as particles that want to
repel one another, but which are tied together by elastic edges. In
ggraph, this can be specified by the <code class="language-plaintext highlighter-rouge">force</code> layout.</p>

    <p>In D3, we can use the <code class="language-plaintext highlighter-rouge">d3.force()</code> function. This animates the
physical system as it settles into an equilibrium state. These can
be visually attractive, but be careful when using this, since the
animation serves no specific visual purpose.</p>
  </li>
  <li>
    <p>One common situation where we can go beyond force-directed graphs is
when we have additional information about the nodes that can be used
to constrain their position. For example, the Royal Constellations
visualization, attempts to visualize the family trees of royal
families. On the y-axis, the nodes are constrained to be sorted by
year, and across the x-axis, nodes are constrained according to the
country of the royal family.</p>
  </li>
  <li>
    <p>More generally, we can define x and y-axis constraints and then use
a force-directed algorithm to layout the nodes, subject to those
constraints. These can be easily implemented by combining D3 with
the cola library.</p>
  </li>
  <li>
    <p>The key line in the example above is
<code class="language-plaintext highlighter-rouge">.constraints(graph.constraints)</code>. This takes a dictionary of pixel
constraints between pairs of nodes; e.g.,
<code class="language-plaintext highlighter-rouge">{"axis":"y", "left":0, "right":1, "gap":25}</code> says that node 1
should be (at least) 25 pixels above node 0.</p>
  </li>
  <li>
    <p>Another common situation is that the nodes can be organized into a
hierarchy of subgraphs. That is, nodes can be partitioned into
non-overlapping sets. These sets can themselves be merged together
to define a coarser partition.</p>
  </li>
  <li>
    <p>This hierarchical structure can be encoded in either node-link or
adjacency matrix visualizations. For example, in node-link views, we
can draw shapes enclosing the sets,</p>

    <p>and in adjacency matrices, we can draw trees specifying the
hierarchy.</p>
  </li>
  <li>
    <p>We can in fact use the cola library to encode hierarchy in node-link
views. The example below uses cola to ensure sets don’t overlap. It
then draws (and fills in) paths that contain the separate sets.</p>
  </li>
  <li>
    <p>In some graphs, we have clustering structure. Within each cluster,
nodes are densely connected, but between clusters, there are only a
few links. In this case, it’s natural to use adjacency matrices to
visualize the clusters and then draw links for connections between
adjacency matrices. The reasoning is that adjacency matrices are
better suited in densely connected graphs (they don’t have the edge
crossing problem) but node-link encodings are better when we want to
follow longer paths across clusters.</p>
  </li>
  <li>
    <p>This is just one example of a larger class of “hybrid” matrix
encodings. It’s possible to solve a variety of visual problems, just
by cleverly combining the elementary visual encodings discussed last
week.</p>
  </li>
  <li>
    <p>So far, we have focused on high-level properties of the graph that
can be accounted for in visualization. Sometimes, the intended
function of the visualization warrants thinking at a low-level
instead. For example, in many problems, we are interested in
studying ego-networks — the small neighborhoods that surround
specific nodes of interest.</p>
  </li>
  <li>
    <p>One example of a layout that was designed to support ego-network
visualization is the egoCompare system. This is a kind of overview +
detail graph visualization where users can select pairs of nodes to
compare within an overview graph. The 2-nearest-neighbor graphs for
each of these selected nodes are then shown (and linked together, if
applicable). The subgraphs are arranged in a way that minimizes the
amount of crossing.</p>
  </li>
  <li>
    <p>The last type of graph we’ll consider in these notes are dynamic
graphs. These are graphs where the sets of nodes and links are
evolving over time. For example, the interactions between proteins
in a protein interaction network may change when a cell is exposed
to environmental stress, like the presence of a virus.</p>
  </li>
  <li>
    <p>There is no single way to visualize these networks, but common
strategies include use of animation, faceting over time, combined
encodings (like time series within nodes), or coordinated views.</p>
  </li>
  <li>
    <p>In these notes, we’ve see some academic literature on visualization.
Even for those of us who are more practically oriented, this
literature can be worth being familiar, if only because it can be a
treasure trove of visual problem solving devices.</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Representing known structure in graphs]]></summary></entry><entry><title type="html">Graph Interactivity I</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week10-2.html" rel="alternate" type="text/html" title="Graph Interactivity I" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week10-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week10-2.html"><![CDATA[<p><em>View interaction in graphs</em></p>

<ol>
  <li>
    <p>Interactivity makes it possible to tinker with different views of a
graph and get immediate feedback. By exploring a sequence of these
views, it can be possible to build up a holistic understand of even
very complex graphs.</p>
  </li>
  <li>
    <p>It’s helpful to think of graph interaction as falling into three
categories, though the boundaries can often be fuzzy. From most
superficial to most substantive, these are,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> * View interactivity: For a fixed mapping from data to visual marks, we alter
 the user’s view so that different regions become easier to study.
 * Encoding interactivity: We can change the visual encodings of a fixed
 collection of data based on user queries.
 * Data interactivity: We can allow the user to manipulate the data that appear
 in any given graph.
</code></pre></div>    </div>

    <p>In these notes, we’ll consider a few examples of view interactivity.
Later, we’ll discuss encoding and data interactivity.</p>
  </li>
  <li>
    <p>A simple form of view interactivity is panning and zooming.
Together, they can be used to change the center and extent of the
user’s field of view. Even though these operations don’t require any
complex redrawing of the graph, they allow a simple form of
overview + detail interactivity. We can zoom out to view the overall
graph and then pan and zoom to specific neighborhoods of interest.</p>
  </li>
  <li>
    <p>In D3, panning and zooming can be implemented using <code class="language-plaintext highlighter-rouge">d3.drag()</code> and
<code class="language-plaintext highlighter-rouge">d3.zoom()</code>, respectively. These are used to construct functions
that can then be called on <code class="language-plaintext highlighter-rouge">g</code> elements containing the objects to
pan and zoom over. For example, to pan and zoom over a simple set of
circles, we can use this block,</p>
  </li>
  <li>
    <p>Application to the graph context works similarly. Here is an example
where we can pan and zoom across a node-link diagram (can you think
of how to do this for an adjacency matrix view?)</p>
  </li>
  <li>
    <p>There are more subtle forms of view interactivity. One interesting
example discussed in the reading for this week is “edge lensing.”
This type of interaction is designed to solve the problem of highly
overlapping edges in dense regions of the graph. For example,
suppose we want to identify the neighbors of a node that lies in the
core of the graph. Since it lies in a dense region, there is a good
chance that many links cross over it, even if they are not direct
neighbors.</p>
  </li>
  <li>
    <p>The idea of the edge lens interaction is to create a “lens” that
hides edges that are not directly relevant to the queried region.
For example, this removes long-range interactions between nodes far
from the lens.</p>
  </li>
  <li>
    <p>We can implement a simple version of this in D3. We can easily draw
a lens by asking a circle to follow our mouse using a mousemove
interaction.</p>
  </li>
  <li>
    <p>Next, we find all the nodes that are contained within the lens. In
the updated view, we redraw edges for these nodes, and we make sure
they lie above the lens.</p>
  </li>
  <li>
    <p>This is not the most efficient implementation, since we draw the
edges within the lens twice (both above and below the lens). In
principle, we could compute the edge / lens intersections and change
the line endpoints as we move. However, the resulting code would be
harder for a new reader to understand, and except in the most
compute-constrained environments, we should prefer readable
implementations (this is in the spirit of “premature optimization is
the root of all evil”).</p>
  </li>
  <li>
    <p>There are a few other forms of lens-based view interactions. A
variant of edge lenses brings all of a node’s neighbors into the
currently hovered view. Fisheye lens are used to distort the view so
that the lensed area gets expanded. The user’s past history of
inputs can be used to define an “interest” function over regions of
the graph, and areas considered more interesting can be expanded to
take up more space in the layout.</p>
  </li>
  <li>
    <p>None of these approaches directly change the graph data (Data
Interactivity) or their encodings (Encoding Interactivity). In the
next set of notes, we’ll consider these more substantive
interactions.</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[View interaction in graphs]]></summary></entry><entry><title type="html">Graph Interactivity II</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week10-3.html" rel="alternate" type="text/html" title="Graph Interactivity II" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week10-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week10-3.html"><![CDATA[<p><em>Encoding and data interaction in graphs</em></p>

<ol>
  <li>
    <p>These notes continue our tour of graph interactivity. We’ll explore
how certain graph queries can be more easily answered by allowing
users to modify visual encodings (Encoding Interactivity) and the
form of the data that are displayed (Data Interactivity).</p>
  </li>
  <li>
    <p>Let’s begin with encoding interactivity. One simple example of this
type of interactivity is highlighting. This changes the visual
appearance of different nodes or edges based on user interest. For
example, in either node link or adjacency matrix views, we can
highlight one-step neighborhoods based on the position of the user’s
mouse. For example, here is an example for node-link views,</p>

    <p>and here is one for adjacency matrix views,</p>
  </li>
  <li>
    <p>Conceptually, there is nothing unique about this interactivity code,
compared to what we already have used for more basic plots (e.g.,
for scatterplots), and many of the techniques we learned earlier
apply here. For example, if want to allow the user to select a node
without placing their mouse directly over it, we could use a voronoi
overlay
<a href="https://bl.ocks.org/alexmacy/15962e97f7a9ebacd55710bf277593d4">https://bl.ocks.org/alexmacy/15962e97f7a9ebacd55710bf277593d4</a>.</p>
  </li>
  <li>
    <p>Brushing and linking is often used for encoding interactivity.
Properly coordinated views can be used to highlight nodes or edges
with a particular property. For example, suppose we wanted to a
simple way of highlighting all the hubs in a network (i.e., nodes
with many neighbors). One idea is to link a histogram of node
degrees with the actual node-link diagram.</p>
  </li>
  <li>
    <p>In principle, we could modify a variety of node and edge attributes
based on user interactions (size, color, line type, …). However,
it’s usually</p>
  </li>
  <li>
    <p>Next, let’s consider data interactions. Two common types of data
interactions are user-guided filtering and aggregation. In
filtering, we remove data from view — this can be determined by UI
inputs, dynamic queries, or direct manipulation of marks on the
screen.</p>
  </li>
  <li>
    <p>For example, in the example below, we filter edges based on their
edge-betweeness-centrality (a measure of how many paths go through
that edge). This is helpful for isolating the “backbone” of the
network.</p>
  </li>
  <li>
    <p>To implement this view, we use the standard enter-update-exit
pattern. We had precomputed the edge centralities in advance, so
updating the displayed marks is simply a matter of determining which
edge array elements to bind.</p>
  </li>
  <li>
    <p>Pruning reduces the number of marks on the display by removing some.
In contrast, aggregation reduces the number of marks by collapsing
many into a few. One approach to aggregation is to clump tightly
connected clusters of nodes into metanodes. This is a special case
of “semantic zooming” — instead of simply resizing a static
collection of elements, semantic zooming modifies the elements that
are shown so that additional details are shown on demand.</p>
  </li>
  <li>
    <p>For example, a semantic zoom with two zoom levels would allow the
user to collapse and expand metanodes based on user interest. We
implement a version of this below, based on the compound graph
visualization from our earlier notes.</p>
  </li>
  <li>
    <p>Both filtering and aggregation work by refocusing our attention on
graph structures, either from the top down (removing less
interesting elements) or from the bottom up (combining similar
ones). An intermediate strategy is based on graph navigation.</p>
  </li>
  <li>
    <p>The main idea of graph navigation is to start zoomed in, with only a
small part of the graph visible. Then, based on user interest, we
can visually signal those directions of the graph that are
especially worth moving towards.</p>
  </li>
  <li>
    <p>Concretely, we can define a degree-of-interest function across the
collection of nodes. This function can update based on user inputs.
The encoding of the graph can then be modified to suggest that
certain regions be focused in on.</p>
  </li>
  <li>
    <p>Note that this is different from the overview-plus-detail principle
that we have used in many places. It is helpful when attempting to
overview the entire network may not be necessary and exploring local
neighborhoods is enough to answer most questions.</p>
  </li>
  <li>
    <p>Together, view, encoding, and data interaction provide a rich set of
techniques for exploring graph data. Moreover, many of the
techniques we described here are still areas of active research, and
perhaps in the future, it will be easier to design and implement
graph interactions suited to specific problems of interest.</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Encoding and data interaction in graphs]]></summary></entry><entry><title type="html">Elements of a Shiny App</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week2-1.html" rel="alternate" type="text/html" title="Elements of a Shiny App" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week2-1</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week2-1.html"><![CDATA[<p><em>Vocabulary used by R Shiny Library, and a few example apps.</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>All Shiny apps are made up from the same few building blocks. These
notes review the main types of blocks. When reading code from more
complex apps, it can be helpful to try to classify pieces of the
code into these types of blocks.</p>
  </li>
  <li>
    <p>The highest level breakdown of Shiny app code is between <code class="language-plaintext highlighter-rouge">ui</code> and
<code class="language-plaintext highlighter-rouge">server</code> components. The <code class="language-plaintext highlighter-rouge">ui</code> controls what the app <em>looks like</em>. It
stands for “User Interface.” The <code class="language-plaintext highlighter-rouge">server</code> controls what the app
<em>does</em>. For example, the app below defines a title and textbox where
users can type. But it does not do anything, since the server is
empty.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello!"),
  textInput("name", "Enter your name")  # first arg is ID, second is label
)

server &lt;- function(input, output) {}
app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/43a4312c-a124-4b63-8228-23ba5375992b/" allowfullscreen="" data-external="1"></iframe>
  </li>
  <li>
    <p>The UI elements can be further broken down into Inputs, Outputs, and
Descriptors[1], all grouped together by an organizing layout
function. Inputs are UI elements that users can manipulate to prompt
certain types of computation. Outputs are parts of the interface
that reflects the result of a <code class="language-plaintext highlighter-rouge">server</code> computation. Descriptors are
parts of the page that aren’t involved in computation, but which
provide narrative structure and guide the user.</p>

    <p>For example, in the toy app above, <code class="language-plaintext highlighter-rouge">titlePage</code> is a descriptor
providing some title text. <code class="language-plaintext highlighter-rouge">textInput</code> is an input element allowing
users to enter text. <code class="language-plaintext highlighter-rouge">fluidPage</code> is a layout function that arranges
these elements on a continuous page (some other layout functions are
<code class="language-plaintext highlighter-rouge">sidebarLayout</code>, <code class="language-plaintext highlighter-rouge">navbarPage</code>, <code class="language-plaintext highlighter-rouge">flowLayout</code>, …)</p>
  </li>
  <li>
    <p>An important point is that all input and output elements must be
given a unique ID. This is always the first argument of a <code class="language-plaintext highlighter-rouge">*Input</code>
or <code class="language-plaintext highlighter-rouge">*Output</code> function defined in Shiny. The ID tags are how
different parts of the application are able to refer to one another.
For example, if we wanted to refer to the text the user entered in
the application above, we could refer to the <code class="language-plaintext highlighter-rouge">name</code> ID.</p>
  </li>
  <li>
    <p>Let’s see how to (1) make user inputs cause some sort of computation
and (2) have the result of that computation appear to the user. For
(1), we will add a <code class="language-plaintext highlighter-rouge">renderText</code> element to the <code class="language-plaintext highlighter-rouge">server</code>. All
<code class="language-plaintext highlighter-rouge">render*</code> functions do two things,</p>

    <ul>
      <li>They make inputs from the <code class="language-plaintext highlighter-rouge">ui</code> available for computation.</li>
      <li>They generate HTML code that allows the results of the
computation to appear in a UI output.</li>
    </ul>

    <p>For (2), we will add a <code class="language-plaintext highlighter-rouge">textOutput</code> element to the <code class="language-plaintext highlighter-rouge">ui</code> layout
defined above. Let’s look at the code,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello!"),
  textInput("name", "Enter your name"),
  textOutput("printed_name")
)

server &lt;- function(input, output) {
  output$printed_name &lt;- renderText({
    paste0("Welcome to shiny, ", input$name, "!")
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/541af110-2ce1-46d1-b293-f38a96e125f3/" allowfullscreen="" data-external="1"></iframe>
  </li>
  <li>
    <p>There are a few points worth noting. First, the <code class="language-plaintext highlighter-rouge">renderText</code>
component was able to refer to the value entered in the textbox
using <code class="language-plaintext highlighter-rouge">input$name</code>. This was possible because <code class="language-plaintext highlighter-rouge">name</code> was the ID that
we gave to the <code class="language-plaintext highlighter-rouge">textInput</code> component. It also would not have worked
if we had used <code class="language-plaintext highlighter-rouge">input$text</code> outside of a <code class="language-plaintext highlighter-rouge">render*</code> function: this is
what we mean by the <code class="language-plaintext highlighter-rouge">render*</code> functions making the UI inputs
available for computation. Finally, we were able to refer to the
rendered output in the UI by adding a <code class="language-plaintext highlighter-rouge">textOutput</code> component. By
giving this component the id <code class="language-plaintext highlighter-rouge">printed_name</code>, we were able to tell it
to look into the server for a rendered output named <code class="language-plaintext highlighter-rouge">printed_name</code>
and fill it in.</p>
  </li>
  <li>
    <p>An even deeper idea is that the code did not simply run linearly,
from top of the script to the bottom. If that were all the code did,
then it would have run once at the beginning, and it would never
have updated when you entered your name. Instead, it ran <em>every time
you typed into the textbox</em>. This is the “reactive programming”
paradigm, and it is what makes interactive visualization possible.
<code class="language-plaintext highlighter-rouge">renderText</code> knows to rerun every time something is entered into the
<code class="language-plaintext highlighter-rouge">name</code> text input, because we told it to depend on <code class="language-plaintext highlighter-rouge">input$name</code>. We
will explore the idea of reactivity in more depth in the next
lecture, but for now, just remember that the order in which code is
executed is not simply determined by the order of lines in a file.</p>
  </li>
  <li>
    <p>Let’s look at a few more examples, just to get a feel for things.
The app below updates a plot of random normal variables given a mean
specified by the user. We’ve introduced a new type of input, a
<code class="language-plaintext highlighter-rouge">numericInput</code>, which captures numbers. We’ve also added a new
output, <code class="language-plaintext highlighter-rouge">plotOutput</code>, allowing with its accompanying renderer,
<code class="language-plaintext highlighter-rouge">renderPlot</code> (remember, UI outputs are always paired with server
renderers).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0), # 0 is the default
  plotOutput("histogram")
)

server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    data.frame(values = rnorm(100, input$mean)) %&gt;%
      ggplot() +
        geom_histogram(aes(values))
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/2cc8cc90-7c51-493c-81e1-a6b8919cd6a6/" allowfullscreen="" data-external="1" height="535" width="600"></iframe>
  </li>
  <li>
    <p>We can make the plot depend on several inputs. The code below allows
the user to change the total number of data points and the variance,
this time using slider inputs. I recommend taking a look at
different inputs on the shiny
<a href="https://shiny.rstudio.com/images/shiny-cheatsheet.pdf">cheatsheet</a>,
though be aware that there are many
<a href="https://github.com/nanxstats/awesome-shiny-extensions">extensions</a>
built by the community.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram")
)

server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    data.frame(values = rnorm(input$n, input$mean, input$sigma)) %&gt;%
      ggplot() +
        geom_histogram(aes(values), bins = 100) +
        xlim(-10, 10)
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/3d0d8a20-446a-438a-b373-bd06206f178f/" allowfullscreen="" data-external="1" height="735" width="600"></iframe>
  </li>
  <li>
    <p>We can also make the app return several outputs, not just a plot.
The code below attempts to print the data along in addition to the
histogram, but it makes a crucial mistake (can you spot it?).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    data.frame(values = rnorm(input$n, input$mean, input$sigma)) %&gt;%
      ggplot() +
        geom_histogram(aes(values), bins = 100) +
        xlim(-10, 10)
  })

  output$dt &lt;- renderDataTable({
    data.frame(values = rnorm(input$n, input$mean, input$sigma))
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/15f7837a-64b6-4f73-9b4a-13f2ca168daa/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
  <li>
    <p>The issue is that this code reruns <code class="language-plaintext highlighter-rouge">rnorm</code> for each output. So, even
though the interfaces suggests that the printed samples are the same
as the ones in the histogram, they are actually different. To
resolve this, we need a way of storing an intermediate computation
which (1) depends on the inputs but (2) feeds into several outputs.
Whenever we encounter this need, we can use a reactive expression.
It is a type of server element that depends on the input and can be
referred to directly by outputs, which call the reactive expression
like a function. For example, the code below generates the random
normal samples a single time, using the <code class="language-plaintext highlighter-rouge">samples()</code> reactive
expression.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    data.frame(values = rnorm(input$n, input$mean, input$sigma))
  })

  output$histogram &lt;- renderPlot({
      ggplot(samples()) +
        geom_histogram(aes(values), bins = 100) +
        xlim(-10, 10)
  })

  output$dt &lt;- renderDataTable(samples())
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/3e53bb63-a19a-4ded-8ab6-5ffbc9447c8f/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
  <li>
    <p>Finally, a good practice is to move as much non-app related code to
separate functions. This makes the flow of the app more transparent.
The clearer the delineation between “computation required for
individual app components” and “relationship across components,” the
easier the code will be to understand and extend.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

### Functions within app components
generate_data &lt;- function(n, mean, sigma) {
  data.frame(values = rnorm(n, mean, sigma))
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(aes(values), bins = 100) +
    xlim(-10, 10)
}

### Defines the app
ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(samples()))
  output$dt &lt;- renderDataTable(samples())
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/fe220e82-becf-4cc6-891c-7fa1c69ba850/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
</ol>

<p>[1] I like to use these names to keep everything organized, but they are
not official, and you do not need to memorize this.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Vocabulary used by R Shiny Library, and a few example apps.]]></summary></entry><entry><title type="html">Introduction to Reactivity</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week2-2.html" rel="alternate" type="text/html" title="Introduction to Reactivity" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week2-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week2-2.html"><![CDATA[<p><em>Viewing shiny code execution as a graph</em></p>

<ol>
  <li>
    <p>These notes will explore the idea of reactivity in more depth.
Recall that reactivity refers to the fact that Shiny app code is not
run from top to bottom, like an ordinary R script. Instead, it runs
reactively, depending on inputs that the user has provided. This can
make writing Shiny code a bit unintuitive at first, but there are a
few higher-level concepts that can help when writing reactive code.</p>
  </li>
  <li>
    <p>The most important of these concepts is that reactive code can be
viewed as a graph. The <code class="language-plaintext highlighter-rouge">ui</code> and <code class="language-plaintext highlighter-rouge">server</code> define an explicit
dependency structure for how components depend on one another. The
<code class="language-plaintext highlighter-rouge">input$</code>’s within <code class="language-plaintext highlighter-rouge">render*</code> functions in the server specify how UI
inputs affect server computations. The IDs within the <code class="language-plaintext highlighter-rouge">*Output</code>
elements in the <code class="language-plaintext highlighter-rouge">ui</code> specify which of the rendered <code class="language-plaintext highlighter-rouge">output$</code>’s in
the server should be used to populate the visible interface.</p>
  </li>
  <li>
    <p>For example, our first “Hello” app has the following (simple)
reactivity graph. Note that I’ve drawn input and output nodes
differently, to emphasize the flow of computation. I’ve also copied
the code from the original app for reference.</p>

    <p><img src="https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-02/figures/names.png" alt="" /></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello!"),
  textInput("name", "Enter your name"),
  textOutput("printed_name")
)

server &lt;- function(input, output) {
  output$printed_name &lt;- renderText({
    paste0("Welcome to shiny, ", input$name, "!")
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/43a4312c-a124-4b63-8228-23ba5375992b/" allowfullscreen="" data-external="1"></iframe>
  </li>
  <li>
    <p>Even though the graph is simple, note that the outputs will be
recomputed each time that the input is changed. For more general
graphs, all downstream nodes will be re-executed whenever an
upstream source is changed (typically by a user input, though it’s
possible to trigger changes automatically).</p>
  </li>
  <li>
    <p>Reactive expressions provide a special kind of node that live
between inputs and outputs. They depend on inputs, and they feed
into outputs, but they are never made directly visible to the user.
This is why we’ve drawn them as a kind of special intermediate node.
Below, I’ve drawn the graph for our random normal plotter, with the
reactive <code class="language-plaintext highlighter-rouge">samples()</code> expression.</p>

    <p><img src="https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-02/figures/reactive_histo.png" alt="" /></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

### Functions within app components
generate_data &lt;- function(n, mean, sigma) {
  data.frame(values = rnorm(n, mean, sigma))
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(aes(values), bins = 100) +
    xlim(-10, 10)
}

### Defines the app
ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(samples()))
  output$dt &lt;- renderDataTable(samples())
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/6063856c-2c50-4bb2-b272-b1c41b30f574/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
  <li>
    <p>A useful perspective is to think of reactive expressions as
simplifying the overall reactivity graph. Specifically, by adding a
reactive node, it’s possible to trim away many edges. For example,
our initial implementation of the random normal plotter (which
didn’t use the reactive expression) has a much more complicated
graph, since many inputs feed directly into outputs.</p>

    <p><img src="https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-02/figures/nonreactive_histo.png" alt="" /></p>
  </li>
  <li>
    <p>Let’s see these principles in action for a similar, but more complex
app. The app below can be used for power analysis. It simulates two
groups of samples, both from normal distributions, but with
different (user specified) means. We’ve used a reactive expression
to generate the samples, so that both the histogram and hypothesis
test result outputs can refer to the same intermediate simulated
data.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(broom)

### Functions within app components
generate_data &lt;- function(n, mean1, mean2, sigma) {
  data.frame(
    values = c(rnorm(n, mean1, sigma), rnorm(n, mean2, sigma)),
    group = rep(c("A", "B"), each = n)
  )
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(
      aes(values, fill = group), 
      bins = 100, position = "identity",
      alpha = 0.8
    ) +
    xlim(-10, 10)
}

test_fun &lt;- function(df) {
  t.test(values ~ group, data = df) %&gt;%
    tidy() %&gt;%
    select(p.value, conf.low, conf.high)
}

### Defines the app
ui &lt;- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("mean1", "Mean (Group 1)", 0, min = -10.0, max = 10.0, step = 0.1),
      sliderInput("mean2", "Mean (Group 2)", 0, min = -10, max = 10, step = 0.1),
      sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
      sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
    ),
    mainPanel(
      plotOutput("histogram"),
      dataTableOutput("test_result")
    )
  )
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean1, input$mean2, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(generate_data(input$n, input$mean1, input$mean2, input$sigma)))
  output$test_result &lt;- renderDataTable(test_fun(generate_data(input$n, input$mean1, input$mean2, input$sigma)))
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/1f5cecd2-a4c7-46bd-a2ea-07443b009687/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>

    <p>Other than that, the only difference is that I’ve saved output from
the <code class="language-plaintext highlighter-rouge">t.test</code> using <code class="language-plaintext highlighter-rouge">test_result</code>. Notice the use of the <code class="language-plaintext highlighter-rouge">broom</code>
package, which helps format the test output into a <code class="language-plaintext highlighter-rouge">data.frame</code>.</p>
  </li>
  <li>
    <p>So far, all of our reactive code has lived within the <code class="language-plaintext highlighter-rouge">render*</code> or
<code class="language-plaintext highlighter-rouge">reactive()</code> sets of functions. However, there is a another kind
that is often useful, especially in more advanced applications:
<code class="language-plaintext highlighter-rouge">observers</code>. An observer is a computation that is done every time
certain inputs are changed, but which don’t affect downstream UI
outputs through a <code class="language-plaintext highlighter-rouge">render*</code> function. For example, below, we’ve
added a block (under <code class="language-plaintext highlighter-rouge">observeEvent</code>) that prints to the console
every time either of the means are changed. I realize it is a bit of
a mystery why these functions would ever be useful, but we will see
them in more realistic contexts next week.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(broom)

### Functions within app components
generate_data &lt;- function(n, mean1, mean2, sigma) {
  data.frame(
    values = c(rnorm(n, mean1, sigma), rnorm(n, mean2, sigma)),
    group = rep(c("A", "B"), each = n)
  )
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(
      aes(values, fill = group), 
      bins = 100, position = "identity",
      alpha = 0.8
    ) +
    xlim(-10, 10)
}

test_fun &lt;- function(df) {
  t.test(values ~ group, data = df) %&gt;%
    tidy() %&gt;%
    select(p.value, conf.low, conf.high)
}

### Defines the app
ui &lt;- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("mean1", "Mean (Group 1)", 0, min = -10.0, max = 10.0, step = 0.1),
      sliderInput("mean2", "Mean (Group 2)", 0, min = -10, max = 10, step = 0.1),
      sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
      sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
    ),
    mainPanel(
      plotOutput("histogram"),
      dataTableOutput("test_result")
    )
  )
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean1, input$mean2, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(samples()))
  output$test_result &lt;- renderDataTable(test_fun(samples()))
  observeEvent(input$mean1 | input$mean2, {
    message("group 1 mean is now: ", input$mean1)
    message("group 2 mean is now: ", input$mean2)
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/752b80de-5c75-4dd9-b7fe-2d399c3ea3da/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Viewing shiny code execution as a graph]]></summary></entry><entry><title type="html">IMDB Shiny Application</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week2-3.html" rel="alternate" type="text/html" title="IMDB Shiny Application" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week2-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week2-3.html"><![CDATA[<p><em>Using Shiny to explore a movies dataset</em></p>

<ol>
  <li>
    <p>So far, all of our Shiny applications have been based on toy
simulated data. In this set of notes, we’ll use Shiny to explore a
real dataset, illustrating the general development workflow in the
process. Before diving into code, let’s consider the role of
interactivity in data analysis.</p>
  </li>
  <li>
    <p>A major difference between doing visualization on paper and on
computers is that visualization on computers can make use of
interactivity. An interactive visualization is one that changes in
response to user cues. This allows a display to update in a way that
provides a visual comparison that was not available in a previous
view. In this way, interactive visualization allows users to answer
a sequence of questions.</p>
  </li>
  <li>
    <p>Selection, both of observations and of attributes, is fundamental to
interactive visualization. This is because it precedes other
interactive operations: you can select a subset of observations to
filter down to or attributes to coordinate across multiple displays
(we consider both types of interactivity in later lectures).</p>
  </li>
  <li>
    <p>The code below selects movies to highlight based on Genre. We use a
<code class="language-plaintext highlighter-rouge">selectInput</code> to create the dropdown menu. A reactive expression
creates a new column (<code class="language-plaintext highlighter-rouge">selected</code>) in the <code class="language-plaintext highlighter-rouge">movies</code> dataset
specifiying whether the current movie is selected. The reactive
graph structure means that the ggplot2 figure is recreated each time
the selection is changed, and the <code class="language-plaintext highlighter-rouge">selected</code> column is used to shade
in the points. This process of changing the visual encoding of
graphical marks depending on user selections is called “conditional
encoding.”</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(lubridate)

movies &lt;- read_csv("https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv") %&gt;%
  mutate(
    date = as_date(Release_Date, format = "%b %d %Y"),
    year = year(date),
    Major_Genre = fct_explicit_na(Major_Genre),
    MPAA_Rating = fct_explicit_na(MPAA_Rating),
  )

genres &lt;- pull(movies, Major_Genre) %&gt;%
  unique() %&gt;%
  na.omit()

### functions used in app
scatterplot &lt;- function(df) {
  ggplot(df) +
    geom_point(
      aes(Rotten_Tomatoes_Rating, IMDB_Rating, size = selected, alpha = selected)
    ) +
    scale_size(limits = c(0, 1), range = c(.5, 2), guide = "none") +
    scale_alpha(limits = c(0, 1), range = c(.1, 1), guide = "none")
}

### definition of app
ui &lt;- fluidPage(
  titlePanel("IMDB Analysis"),
  selectInput("genres", "Genre", genres),
  plotOutput("ratings_scatter")
)

server &lt;- function(input, output) {
  movies_subset &lt;- reactive({
    movies %&gt;%
      mutate(selected = 1 * (Major_Genre %in% input$genres))
  })

  output$ratings_scatter &lt;- renderPlot({
    scatterplot(movies_subset())
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/02971f81-3af5-4fdb-89d7-84a663778546/" allowfullscreen="" data-external="1" height="550" width="600"></iframe>

    <p><img src="/https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/figures/initial_imdb.png" alt="" /></p>
  </li>
  <li>
    <p>We can extend this further. Let’s allow the user to filter by year
and MPAA rating. Notice that there are some years in the future! We
also find that there are systematic differences in IMDB and Rotten
Tomatoes ratings as a function of these variables.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(lubridate)

movies &lt;- read_csv("https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv") %&gt;%
  mutate(
    date = as_date(Release_Date, format = "%b %d %Y"),
    year = year(date),
    Major_Genre = fct_explicit_na(Major_Genre),
    MPAA_Rating = fct_explicit_na(MPAA_Rating),
  )

genres &lt;- pull(movies, Major_Genre) %&gt;%
  unique() %&gt;%
  na.omit()
ratings &lt;- pull(movies, MPAA_Rating) %&gt;%
  unique() %&gt;%
  na.omit()

### functions used in app
scatterplot &lt;- function(df) {
  ggplot(df) +
    geom_point(
      aes(Rotten_Tomatoes_Rating, IMDB_Rating, size = selected, alpha = selected)
    ) +
    scale_size(limits = c(0, 1), range = c(.5, 2), guide = "none") +
    scale_alpha(limits = c(0, 1), range = c(.1, 1), guide = "none")
}

### definition of app
ui &lt;- fluidPage(
  titlePanel("IMDB Analysis"),
  selectInput("genres", "Genre", genres, multiple = TRUE),
  checkboxGroupInput("mpaa", "MPAA Rating", ratings, ratings),
  sliderInput("year", "Year", min = min(movies$year), max = max(movies$year), c(1928, 2020), sep = ""),
  plotOutput("ratings_scatter")
)

server &lt;- function(input, output) {
  movies_subset &lt;- reactive({
    movies %&gt;%
      mutate(selected = 1 * (
        (Major_Genre %in% input$genres) &amp;
        (MPAA_Rating %in% input$mpaa) &amp;
        (year &gt;= input$year[1]) &amp;
        (year &lt;= input$year[2])
      ))
  })

  output$ratings_scatter &lt;- renderPlot({
    scatterplot(movies_subset())
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/9036974c-176a-4e9b-963d-c25eb45f5635/" allowfullscreen="" data-external="1" height="900" width="600"></iframe>

    <p><img src="/https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/figures/final_imdb.png" alt="" /></p>
  </li>
  <li>
    <p>We’ll include a final version of this plot which additionally shows
the movie name when points are hovered. To accomplish this, we can
no longer use <code class="language-plaintext highlighter-rouge">ggplot2</code> on its own – it has to be linked with a
plotting library that renders web-based visualizations (not just
static image files). This is what the <code class="language-plaintext highlighter-rouge">ggplotly()</code> call does in the
updated version of the app. The mouseover text is added through the
<code class="language-plaintext highlighter-rouge">tooltip</code> argument.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(lubridate)
library(plotly)

movies &lt;- read_csv("https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv") %&gt;%
  mutate(
    date = as_date(Release_Date, format = "%b %d %Y"),
    year = year(date),
    Major_Genre = fct_explicit_na(Major_Genre),
    MPAA_Rating = fct_explicit_na(MPAA_Rating),
  )

genres &lt;- pull(movies, Major_Genre) %&gt;%
  unique() %&gt;%
  na.omit()
ratings &lt;- pull(movies, MPAA_Rating) %&gt;%
  unique() %&gt;%
  na.omit()

### functions used in app
scatterplot &lt;- function(df) {
  p &lt;- ggplot(mapping = aes(Rotten_Tomatoes_Rating, IMDB_Rating)) +
    geom_point(data = df %&gt;% filter(selected),  aes(text = Title), size = 2, alpha = 1) +
    geom_point(data = df %&gt;% filter(!selected),  size = .5, alpha = .1)
  ggplotly(p, tooltip = "Title") %&gt;%
    style(hoveron = "fill")
}

### definition of app
ui &lt;- fluidPage(
  titlePanel("IMDB Analysis"),
  selectInput("genres", "Genre", genres),
  checkboxGroupInput("mpaa", "MPAA Rating", ratings, ratings),
  sliderInput("year", "Year", min = min(movies$year), max = max(movies$year), c(1928, 2020), sep = ""),
  plotlyOutput("ratings_scatter")
)

server &lt;- function(input, output) {
  movies_subset &lt;- reactive({
    movies %&gt;%
      mutate(selected = (
        (Major_Genre %in% input$genres) &amp;
        (MPAA_Rating %in% input$mpaa) &amp;
        (year &gt;= input$year[1]) &amp;
        (year &lt;= input$year[2])
      ))
  })

  output$ratings_scatter &lt;- renderPlotly({
    scatterplot(movies_subset())
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/2151742d-4b80-4200-9b91-55dda592a9f6/" allowfullscreen="" data-external="1" height="900" width="600"></iframe>
  </li>
  <li>
    <p>These visualizations are an instance of the more general idea of
using filtering to reduce complexity in data. Filtering is an
especially powerful technique in the interactive paradigm, where it
is possible to easily reverse (or compare) filtering choices.</p>
  </li>
  <li>
    <p>Conceptually, what we are doing falls under the name of “Dynamic
Querying,” which refers more generally to updating a visualization
based on user queries. There are several ways to think about these
dynamic queries,</p>

    <ul>
      <li>Interpretation 1: Dynamic queries create the visual analog of a
database interaction. Rather than using a programming-based
interface to filter elements or select attributes, we can design
interactive visual equivalents.</li>
      <li>Interpretation 2: Dynamic queries allow rapid evaluation of
conditional probabilities. The visualization above was designed
to answer: What is the joint distribution of movie ratings,
conditional on being a drama?</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Using Shiny to explore a movies dataset]]></summary></entry></feed>