<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/stat679_notes/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/stat679_notes/" rel="alternate" type="text/html" /><updated>2022-06-12T16:30:45-05:00</updated><id>http://localhost:4000/stat679_notes/feed.xml</id><title type="html">Statistical Data Visualization</title><subtitle>These are notes from STAT 679 (Fall 2022) at UW Madison.</subtitle><entry><title type="html">Node - Link Diagrams</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week9-2.html" rel="alternate" type="text/html" title="Node - Link Diagrams" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week9-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week9-2.html"><![CDATA[<p><strong>Representing relations with line marks</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(ggraph)
library(tidygraph)
theme_set(theme_graph())
</code></pre></div></div>

<ol>
  <li>
    <p>A node-link diagram is a visual encoding strategy for network data,
where nodes are drawn as points and links between nodes are drawn as
lines between them. The dataset below is a friendship network
derived from a survey of high schoolers in 1957 and 1958, available
in the <code class="language-plaintext highlighter-rouge">tidygraph</code> package.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>G_school &lt;- as_tbl_graph(highschool) %&gt;%
  activate(edges) %&gt;%
  mutate(year = factor(year))
ggraph(G_school) +
  geom_edge_link(aes(col = year), width = 0.1) +
  geom_node_point()
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week9-2/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p>For trees, the vertical or radial position can further encode the
depth of a node in the tree. The data below represent the directory
structure from a widely used web package called flare.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>G_flare &lt;- tbl_graph(flare$vertices, flare$edges)
p1 &lt;- ggraph(G_flare, 'tree') + 
  geom_edge_link() +
  geom_node_label(aes(label = shortName), size = 3)
p2 &lt;- ggraph(G_flare, 'tree', circular = TRUE) + 
  geom_edge_link() +
  geom_node_label(aes(label = shortName), size = 3)

library(patchwork)
p1 + p2
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week9-2/unnamed-chunk-4-1.png" alt="The same node-link diagram, with either height or radius encoding
depth in the
tree." /></p>
  </li>
  <li>
    <p>In either trees or networks, attributes of nodes and edges can be
encoded using size (node radius or edge width) or color.</p>
  </li>
  <li>
    <p>The node-link representation is especially effective for the task of
following paths. It’s an intuitive visualization for examining the
local neighborhood of one node or describing the shortest path
between two nodes.</p>
  </li>
  <li>
    <p>In node-link diagrams, spatial position is subtle. It does not
directly encode any attribute in the dataset, but layout algorithms
(i.e., algorithms that try to determine the spatial positions of
nodes in a node-link diagram) try to ensure that nodes that are
close to one another in the shortest-path-sense also appear close to
one another on the page.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p1 &lt;- ggraph(G_school, layout = "kk") +
  geom_edge_link(aes(col = year), width = 0.1) +
  geom_node_point()
p2 &lt;- ggraph(G_school, layout = "fr") +
  geom_edge_link(aes(col = year), width = 0.1) +
  geom_node_point()
p1 + p2
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week9-2/unnamed-chunk-5-1.png" alt="A comparison of two layout algorithms for the same
network." /></p>
  </li>
  <li>
    <p>One common layout algorithm uses force-directed placement. The edges
here are interpreted as physical springs, and the node positions are
iteratively updated according to the forces induced by the springs.</p>
  </li>
  <li>
    <p>The key drawback of node-link diagrams is that they do not scale
well to networks with a large number of nodes or with a large number
of edges per node. The nodes and edges begin to overlap too much,
and the result looks like a “hairball.”</p>
  </li>
  <li>
    <p>In this situation, it is possible to use additional structure in the
data to salvage the node-link display. For example, in a large tree,
a rectangular or BubbleTree layout can be used.</p>

    <figure>

<img src="https://uwmadison.box.com/shared/static/r9boadgujdkp0xy3hk23n6j2ri13yh6h.png" alt="Recommendation network" />

<figcaption>

Example rectangular and BubbleTree layouts, for very large trees, as
shown in Visualization Analysis and Design.

</figcaption>
</figure>
  </li>
</ol>

<p>If a large network has a modular structure, then it is possible to first
lay out the separate clusters far apart from one another, before running
force directed placement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;figure&gt;
&lt;img src="https://uwmadison.box.com/shared/static/0zihaty78j8ytmdjwlqetbxpjzbrz8k6.png"
     alt="Hierarchical layout"&gt;
&lt;figcaption&gt;A hierarchical force directed layout algorithm, as shown in Visualization Analysis and Design.&lt;/figcaption&gt;
</code></pre></div></div>

<p>&lt;/figure&gt;</p>

<p>If many edges go through a few shared paths, it may be possible to
bundle them.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;figure&gt;
&lt;img src="https://www.data-to-viz.com/graph/IMG/bundle_compare.png"
     alt="Hierarchical layout"&gt;
&lt;figcaption&gt;In edge bundling, similar paths are placed close to one another.
&lt;/figcaption&gt;
</code></pre></div></div>

<p>&lt;/figure&gt;</p>

<p>Bundled connections can be visualized using the <code class="language-plaintext highlighter-rouge">geom_conn_bundle</code>
geometry in ggraph. Before using this layout, it is necessary to have a
hierarchy over all the nodes, since shared ancestry among connected
nodes is how the proximity of paths is determined.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```r
from &lt;- match(flare$imports$from, flare$vertices$name)
to &lt;- match(flare$imports$to, flare$vertices$name)
ggraph(G_flare, layout = 'dendrogram', circular = TRUE) + 
  geom_conn_bundle(data = get_con(from = from, to = to), alpha = 0.1) + 
  geom_node_label(aes(label = shortName), size = 2) +
  coord_fixed()
```

![An example of hierarchical edge bundling in R.](/stat679_notes/assets/week9-2/unnamed-chunk-6-1.png)
</code></pre></div></div>

<ol>
  <li>To summarize, node-link diagrams are very good for characterizing
local structure, but struggle with large networks.</li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Representing relations with line marks]]></summary></entry><entry><title type="html">Visual Encodings</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-2.html" rel="alternate" type="text/html" title="Visual Encodings" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-2.html"><![CDATA[<p><em>Design principles from the grammar of graphics.</em></p>

<ol>
  <li>
    <p>Visualizations link abstract data with the physical, geometric
marks,</p>

    <ul>
      <li>Each observation (row) within a dataset corresponds to a
geometric mark in a visualization.</li>
      <li>Important attributes (columns) of an observation within a
dataset can be encoded by properties of visual marks.</li>
    </ul>

    <p>This encoding of rows as marks and columns as properties of the
marks is illustrated in the toy diagram below.</p>

    <p><img src="/stat679_notes/assets/week1-1/encoding_illustration.png" alt="" /></p>
  </li>
  <li>
    <p>A good visualization makes it easy to visually compare the relevant
attributes across observations. A challenge is that there are often
many possible marks and encodings for any given comparison. It’s
also difficult to know which comparisons are actually of interest.
For these reasons, we’re going to want to build up a vocabulary of
marks and encodings.</p>

    <p><img src="/stat679_notes//assets/week1-1/example_encodings.png" alt="" /></p>
  </li>
  <li>
    <p>To identify good encodings, it can often help to first what the
types of each field are.</p>

    <ul>
      <li>Nominal: These are fields that allow identity comparisons
between observations (is <em>A</em> = <em>B</em>?), but don’t come with any
notion of order.
        <ul>
          <li>City region, country name, movie genres, file types, …</li>
        </ul>
      </li>
      <li>Ordinal: These are fields that allow ordering comparisons
between observations (is <em>A</em> &gt; <em>B</em>?), but don’t let you
quantify the degree of difference.
        <ul>
          <li>Shirt size, sports team rankings, order of appearance of
characters on TV show</li>
        </ul>
      </li>
      <li>Quantitative: These are field types that let you make distance
comparisons between observations. For interval data, absolute
comparisons can be made (<em>A</em> − <em>B</em>), while for ratio data, only
relative ones ($\frac{A}{B}$) are possible.
        <ul>
          <li>Temperature, stock price, number of drinks sold in a coffee
shop per day</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>This is not an exhaustive list, and there are subtleties,</p>

    <ul>
      <li>The same field could be treated as nominal, ordinal, or
quantitative depending on the context. Age could be nominal
(underage or overage), ordinal (gen Z, millenial, …), or
quantitative.</li>
      <li>A given field might be thought of hierarchically. There might be
interesting patterns at the city, county, or region level – what
seems like a single column can become the source for multiple
derived fields.</li>
      <li>Even though temporal fields can be thought of as quantitative,
they come with their own conventions. For example, the hour -
week - month hierarchy is a natural one for temporal data.</li>
    </ul>
  </li>
  <li>
    <p>It’s worth highlighting that, even if a particular encoding <em>could</em>
be used for a given data type, different encodings have different
effectiveness. When trying to encoding several data fields at once,
a choice of one encoding over another will implicitly prioritize
certain comparisons over others.</p>

    <p>For example, in the figure below (Figure 5.8
<a href="https://search.library.wisc.edu/catalog/9911196629502121">here</a>),
the same two numbers are encoded using many different visual
properties – position on a shared <em>y</em>-axis, position on distinct
<em>y</em>-axes, etc. – and study participants were asked to gauge the
difference in the numbers. People were best at comparing positions
on a common scale, and worst at distinguishing differences in areas.</p>

    <p><img src="/stat679_notes/assets/week1-1/encoding_effectiveness.png" alt="" /></p>
  </li>
  <li>
    <p>Here is a similar example. In the left four panels, a nominal field
is encoded using color (left two) and shape (middle two). The red
circles are easiest to find in the left two. In the right two
panels, two nominal fields are encoded, using both shape and color.
It’s much harder to find the red circle – you have to scan over the
entire image to find it, which you didn’t have to do at all for the
first two panels.</p>

    <p><img src="/stat679_notes/assets/week1-1/encoding_effectiveness_2.png" alt="" /></p>
  </li>
  <li>
    <p>Implicit in this discussion is that there is never any “perfect”
visualization for a given dataset – the quality of a visualization
is a function of its intended purpose. What comparisons do you want
to facilitate? The choice of encoding will strongly affect the types
of comparisons that are easy to perform.</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Design principles from the grammar of graphics.]]></summary></entry><entry><title type="html">A Vocabulary of Marks</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-3.html" rel="alternate" type="text/html" title="A Vocabulary of Marks" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-3.html"><![CDATA[<p><em>Encoding options in ggplot2</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(scales)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>The choice of encodings influences (1) the types of comparisons that
a visualization suggests and (2) the accuracy of the conclusions
that readers leave with. With this in mind, it’s in our best
interest to build a rich vocabulary of potential visual encodings.
The more kinds of marks and encodings that are at your fingertips,
the better your chances are that you’ll arrive at a configuration
that helps you achieve your purpose.</p>
  </li>
  <li>
    <p><strong>Point marks</strong> can encode data fields using their x and y
positions, color, size, and shape. Below, each mark is a country,
and we’re using shape and the y position to distinguish between
country clusters.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gapminder &lt;- read_csv("https://uwmadison.box.com/shared/static/dyz0qohqvgake2ghm4ngupbltkzpqb7t.csv", col_types = cols()) %&gt;%
  mutate(cluster = as.factor(cluster)) # specify that cluster is nominal
gap2000 &lt;- gapminder %&gt;%
  filter(year == 2000) # keep only year 2000
    ggplot(gap2000) +
      geom_point(aes(x = fertility, y = cluster, shape = cluster))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Bar marks</strong> Bar marks let us associate a continuous field with a
nominal one.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(gap2000) +
  geom_col(aes(country, pop))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-4-1.png" alt="" /></p>
  </li>
  <li>
    <p>This plot can be improved. The grid lines and tick marks associated
with each bar are distracting and the axis labels are all running
over one another. We resolve this by changing the theme and turning
the bars on their side[1]</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(gap2000) +
      geom_col(aes(pop, country)) +
      theme(
        panel.grid.major.y = element_blank(),
        axis.ticks = element_blank() # remove tick marks
      )
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>To make comparisons between countries with similar populations
easier, we can order them by population (alphabetical ordering is
not that meaningful). To compare clusters, we can color in the bars.</p>
  </li>
  <li>
    <p>We’ve been spending a lot of time on this plot. This is because I
want to emphasize that a visualization is not just something we can
get just by memorizing some magic (programming) incantation.
Instead, it is something worth critically engaging with and
refining, in a similar way that we would refine an essay or speech.
Philosophy aside, there are still a few points that need to be
improved in this figure,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> * The axis titles are not meaningful.
 * There is a strange gap between the left hand edge of the plot and the start of the bars.
 * I would also prefer if the bars were exactly touching one another, without the small vertical gap.
 * The scientific notation for population size is unnecessarily technical.
 * The color scheme is a bit boring^[.
</code></pre></div>    </div>
  </li>
  <li>
    <p>I’ve addressed each issue in the block below. Can you tell which
piece of code makes which change? Try removing different components
to verify your guesses.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cols &lt;- c("#80BFA2", "#7EB6D9", "#3E428C", "#D98BB6", "#BF2E21", "#F23A29")
    ggplot(gap2000) +
       geom_col(
         aes(pop, reorder(country, pop), fill = cluster),
         width = 1
       ) +
       scale_x_continuous(label = label_number_si(), expand = c(0, 0, 0.1, 0.1)) +
       scale_fill_manual(values = cols) +
       labs(x = "Population", y = "Country", fill = "Country Group", color = "Country Group") +
       theme(
         axis.ticks = element_blank(),
         panel.grid.major.y = element_blank()
       )
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-6-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Segment marks</strong>. In the plot above, each bar is anchored at 0.
Instead, we could have each bar encode two continuous values, a left
and right. To illustrate, let’s compare the minimum and maximimum
life expectancies within each country cluster. We’ll need to create
a new data.frame with just the summary information. For this, we
<code class="language-plaintext highlighter-rouge">group_by</code> each cluster, so that a summarise call finds the minimum
and maximum life expectancies restricted to each cluster.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># find summary statistics
life_ranges &lt;- gap2000 %&gt;%
  group_by(cluster) %&gt;%
  summarise(
    min_life = min(life_expect),
    max_life = max(life_expect)
  )

ggplot(life_ranges) +
  geom_segment(
    aes(min_life, reorder(cluster, max_life), xend = max_life, yend = cluster, col = cluster),
    size = 5,
  ) +
  scale_color_manual(values = cols) +
  labs(x = "Minimum and Maximum Expected Span", col = "Country Group", y = "Country Group") +
  xlim(0, 85) # otherwise would only range from 42 to 82
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-7-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Line marks</strong> are useful for comparing changes. Our eyes naturally
focus on rates of change when we see lines. Below, we’ll plot the
fertility over time, colored in by country cluster. The group
argument is useful for ensuring each country gets its own line; if
we removed it, ggplot2 would become confused by the fact that the
same x (year) values are associated with multiple y’s (fertility
rates).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(gapminder) +
      geom_line(
        aes(year, fertility, col = cluster, group = country),
          alpha = 0.7, size = 0.9
      ) +
      scale_x_continuous(expand = c(0, 0)) +  # same trick of removing gap
      scale_color_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
  <li>
    <p>Area marks have a flavor of both bar and line marks. The filled area
supports absolute comparisons, while the changes in shape suggest
derivatives.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_sums &lt;- gapminder %&gt;%
  group_by(year, cluster) %&gt;%
  summarise(total_pop = sum(pop))

ggplot(population_sums) +
  geom_area(aes(year, total_pop, fill = cluster)) +
  scale_y_continuous(expand = c(0, 0, .1, .1), label = label_number(cut_short_scale())) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-9-1.png" alt="" /></p>
  </li>
  <li>
    <p>Just like in bar marks, we don’t necessarily need to anchor the
y-axis at 0. For example, here the bottom and top of each area mark
is given by the 30% and 70% quantiles of population within each
country cluster.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_ranges &lt;- gapminder %&gt;%
  group_by(year, cluster) %&gt;%
  summarise(min_pop = quantile(pop, 0.3), max_pop = quantile(pop, 0.7))

ggplot(population_ranges) +
  geom_ribbon(
    aes(x = year, ymin = min_pop, ymax = max_pop, fill = cluster),
    alpha = 0.8
  ) +
  scale_y_continuous(expand = c(0, 0, .1, .1), label = label_number_si()) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-10-1.png" alt="" /></p>
  </li>
</ol>

<p>[1] An alternative is to turn rotate the labels by 90 degrees. I prefer
to turn the whole plot this, because this way, readers don’t have to
tilt their heads to read the country names.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Encoding options in ggplot2]]></summary></entry><entry><title type="html">Small Multiples and Faceting</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-4.html" rel="alternate" type="text/html" title="Small Multiples and Faceting" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-4</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-4.html"><![CDATA[<p><em>Increased information density through faceting</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(dslabs)
library(tidyverse)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>It might seem like we’re limited with the total number of variables
we can display at a time. While there are many types of encodings we
could in theory use, only a few them are very effective, and they
can interfere with one another.</p>
  </li>
  <li>
    <p>Not all is lost, though! A very useful idea for visualizing
high-dimensional data is the idea of small multiples. It turns out
that our eyes are pretty good at making sense of many small plots,
as long as there is some shared structure across the plots.</p>

    <p><img src="https://krisrs1128.github.io/stat479/posts/2021-01-20-week2-1/assets/sparklines.png" alt="" /></p>
  </li>
  <li>
    <p>In ggplot2, we can implement this idea using the <code class="language-plaintext highlighter-rouge">facet_wrap</code> and
<code class="language-plaintext highlighter-rouge">facet_grid</code> commands. We specify the column in the data.frame along
which we want to generate comparable small multiples.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>years &lt;- c(1962, 1980, 1990, 2000, 2012)
continents &lt;- c("Europe", "Asia")
gapminder_subset &lt;- gapminder %&gt;%
  filter(year %in% years, continent %in% continents)

ggplot(
    gapminder_subset, 
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(. ~ year) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p>In facet grid, you specify whether you want the plot to be repeated
across rows or columns, depending on whether you put the variable
before or after the tilde.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder_subset, 
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(year ~ .) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-4-1.png" alt="" /></p>
  </li>
  <li>
    <p>You can also facet by more than one variable at a time, specifying
which variables should go in rows and which should go in columns
again using the tilde.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder %&gt;% filter(year %in% years),
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(year ~ continent) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>Sometimes, you just want to see the display repeated over groups,
but you don’t really need them to all appear in the same row or
column. In this case, you can use <code class="language-plaintext highlighter-rouge">facet_wrap</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder %&gt;% filter(year %in% years),
    aes(x = fertility, y = life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_wrap(~ year)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-6-1.png" alt="" /></p>
  </li>
  <li>
    <p>Just to illustrate, faceting makes sense for datasets other than
scatterplots. This example also shows that faceting will apply to
multiple geom layers at once. The dataset below shows the abundances
of five different bacteria across three different subjects over
time, as they were subjected to antibiotics. The data were the basis
for [this study](&lt;)&gt;.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>antibiotic &lt;- read_csv("https://uwmadison.box.com/shared/static/5jmd9pku62291ek20lioevsw1c588ahx.csv")
head(antibiotic)

## # A tibble: 6 × 7
##   species  sample value ind    time svalue antibiotic     
##   &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          
## 1 Unc05qi6 D1         0 D         1   NA   Antibiotic-free
## 2 Unc05qi6 D2         0 D         2   NA   Antibiotic-free
## 3 Unc05qi6 D3         0 D         3    0   Antibiotic-free
## 4 Unc05qi6 D4         0 D         4    0   Antibiotic-free
## 5 Unc05qi6 D5         0 D         5    0   Antibiotic-free
## 6 Unc05qi6 D6         0 D         6    0.2 Antibiotic-free
</code></pre></div>    </div>
  </li>
  <li>
    <p>I have also separately computed running averages for each of the
variables – this is in the <code class="language-plaintext highlighter-rouge">svalue</code> column.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(antibiotic, aes(x = time)) +
      geom_line(aes(y = svalue), size = 1.2) +
      geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
      facet_grid(species ~ ind) +
      scale_color_brewer(palette = "Set2") +
      theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
  <li>
    <p>It seems like some of the species are much more abundant than
others. In this situation, it might make sense to rescale the
y-axis. Though, this is always a risky decision – people might
easily misinterpret the plot and conclude that the different species
all have the same abundances. Nonetheless, it can’t hurt to try,
using the scale argument to <code class="language-plaintext highlighter-rouge">facet_grid</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(antibiotic, aes(x = time)) +
      geom_line(aes(y = svalue), size = 1.2) +
      geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
      facet_grid(species ~ ind, scale = "free_y") +
      scale_color_brewer(palette = "Set2") +
      theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-9-1.png" alt="" /></p>
  </li>
  <li>
    <p>Unlike the years example, the facets don’t automatically come with
their own natural order. We can define an order based on the average
value of the responses over the course of the survey.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(antibiotic, aes(x = time)) +
  geom_line(aes(y = svalue), size = 1.2) +
  geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
  facet_grid(reorder(species, value, mean) ~ ind, scale = "free_y") +
  scale_color_brewer(palette = "Set2") +
  theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-10-1.png" alt="" /></p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Increased information density through faceting]]></summary></entry><entry><title type="html">Elements of a Shiny App</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week2-1.html" rel="alternate" type="text/html" title="Elements of a Shiny App" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week2-1</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week2-1.html"><![CDATA[<p><em>Vocabulary used by R Shiny Library, and a few example apps.</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>All Shiny apps are made up from the same few building blocks. These
notes review the main types of blocks. When reading code from more
complex apps, it can be helpful to try to classify pieces of the
code into these types of blocks.</p>
  </li>
  <li>
    <p>The highest level breakdown of Shiny app code is between <code class="language-plaintext highlighter-rouge">ui</code> and
<code class="language-plaintext highlighter-rouge">server</code> components. The <code class="language-plaintext highlighter-rouge">ui</code> controls what the app <em>looks like</em>. It
stands for “User Interface.” The <code class="language-plaintext highlighter-rouge">server</code> controls what the app
<em>does</em>. For example, the app below defines a title and textbox where
users can type. But it does not do anything, since the server is
empty.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello!"),
  textInput("name", "Enter your name")  # first arg is ID, second is label
)

server &lt;- function(input, output) {}
app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/43a4312c-a124-4b63-8228-23ba5375992b/" allowfullscreen="" data-external="1"></iframe>
  </li>
  <li>
    <p>The UI elements can be further broken down into Inputs, Outputs, and
Descriptors[1], all grouped together by an organizing layout
function. Inputs are UI elements that users can manipulate to prompt
certain types of computation. Outputs are parts of the interface
that reflects the result of a <code class="language-plaintext highlighter-rouge">server</code> computation. Descriptors are
parts of the page that aren’t involved in computation, but which
provide narrative structure and guide the user.</p>

    <p>For example, in the toy app above, <code class="language-plaintext highlighter-rouge">titlePage</code> is a descriptor
providing some title text. <code class="language-plaintext highlighter-rouge">textInput</code> is an input element allowing
users to enter text. <code class="language-plaintext highlighter-rouge">fluidPage</code> is a layout function that arranges
these elements on a continuous page (some other layout functions are
<code class="language-plaintext highlighter-rouge">sidebarLayout</code>, <code class="language-plaintext highlighter-rouge">navbarPage</code>, <code class="language-plaintext highlighter-rouge">flowLayout</code>, …)</p>
  </li>
  <li>
    <p>An important point is that all input and output elements must be
given a unique ID. This is always the first argument of a <code class="language-plaintext highlighter-rouge">*Input</code>
or <code class="language-plaintext highlighter-rouge">*Output</code> function defined in Shiny. The ID tags are how
different parts of the application are able to refer to one another.
For example, if we wanted to refer to the text the user entered in
the application above, we could refer to the <code class="language-plaintext highlighter-rouge">name</code> ID.</p>
  </li>
  <li>
    <p>Let’s see how to (1) make user inputs cause some sort of computation
and (2) have the result of that computation appear to the user. For
(1), we will add a <code class="language-plaintext highlighter-rouge">renderText</code> element to the <code class="language-plaintext highlighter-rouge">server</code>. All
<code class="language-plaintext highlighter-rouge">render*</code> functions do two things,</p>

    <ul>
      <li>They make inputs from the <code class="language-plaintext highlighter-rouge">ui</code> available for computation.</li>
      <li>They generate HTML code that allows the results of the
computation to appear in a UI output.</li>
    </ul>

    <p>For (2), we will add a <code class="language-plaintext highlighter-rouge">textOutput</code> element to the <code class="language-plaintext highlighter-rouge">ui</code> layout
defined above. Let’s look at the code,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello!"),
  textInput("name", "Enter your name"),
  textOutput("printed_name")
)

server &lt;- function(input, output) {
  output$printed_name &lt;- renderText({
    paste0("Welcome to shiny, ", input$name, "!")
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/541af110-2ce1-46d1-b293-f38a96e125f3/" allowfullscreen="" data-external="1"></iframe>
  </li>
  <li>
    <p>There are a few points worth noting. First, the <code class="language-plaintext highlighter-rouge">renderText</code>
component was able to refer to the value entered in the textbox
using <code class="language-plaintext highlighter-rouge">input$name</code>. This was possible because <code class="language-plaintext highlighter-rouge">name</code> was the ID that
we gave to the <code class="language-plaintext highlighter-rouge">textInput</code> component. It also would not have worked
if we had used <code class="language-plaintext highlighter-rouge">input$text</code> outside of a <code class="language-plaintext highlighter-rouge">render*</code> function: this is
what we mean by the <code class="language-plaintext highlighter-rouge">render*</code> functions making the UI inputs
available for computation. Finally, we were able to refer to the
rendered output in the UI by adding a <code class="language-plaintext highlighter-rouge">textOutput</code> component. By
giving this component the id <code class="language-plaintext highlighter-rouge">printed_name</code>, we were able to tell it
to look into the server for a rendered output named <code class="language-plaintext highlighter-rouge">printed_name</code>
and fill it in.</p>
  </li>
  <li>
    <p>An even deeper idea is that the code did not simply run linearly,
from top of the script to the bottom. If that were all the code did,
then it would have run once at the beginning, and it would never
have updated when you entered your name. Instead, it ran <em>every time
you typed into the textbox</em>. This is the “reactive programming”
paradigm, and it is what makes interactive visualization possible.
<code class="language-plaintext highlighter-rouge">renderText</code> knows to rerun every time something is entered into the
<code class="language-plaintext highlighter-rouge">name</code> text input, because we told it to depend on <code class="language-plaintext highlighter-rouge">input$name</code>. We
will explore the idea of reactivity in more depth in the next
lecture, but for now, just remember that the order in which code is
executed is not simply determined by the order of lines in a file.</p>
  </li>
  <li>
    <p>Let’s look at a few more examples, just to get a feel for things.
The app below updates a plot of random normal variables given a mean
specified by the user. We’ve introduced a new type of input, a
<code class="language-plaintext highlighter-rouge">numericInput</code>, which captures numbers. We’ve also added a new
output, <code class="language-plaintext highlighter-rouge">plotOutput</code>, allowing with its accompanying renderer,
<code class="language-plaintext highlighter-rouge">renderPlot</code> (remember, UI outputs are always paired with server
renderers).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0), # 0 is the default
  plotOutput("histogram")
)

server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    data.frame(values = rnorm(100, input$mean)) %&gt;%
      ggplot() +
        geom_histogram(aes(values))
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/2cc8cc90-7c51-493c-81e1-a6b8919cd6a6/" allowfullscreen="" data-external="1" height="535" width="600"></iframe>
  </li>
  <li>
    <p>We can make the plot depend on several inputs. The code below allows
the user to change the total number of data points and the variance,
this time using slider inputs. I recommend taking a look at
different inputs on the shiny
<a href="https://shiny.rstudio.com/images/shiny-cheatsheet.pdf">cheatsheet</a>,
though be aware that there are many
<a href="https://github.com/nanxstats/awesome-shiny-extensions">extensions</a>
built by the community.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram")
)

server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    data.frame(values = rnorm(input$n, input$mean, input$sigma)) %&gt;%
      ggplot() +
        geom_histogram(aes(values), bins = 100) +
        xlim(-10, 10)
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/3d0d8a20-446a-438a-b373-bd06206f178f/" allowfullscreen="" data-external="1" height="735" width="600"></iframe>
  </li>
  <li>
    <p>We can also make the app return several outputs, not just a plot.
The code below attempts to print the data along in addition to the
histogram, but it makes a crucial mistake (can you spot it?).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    data.frame(values = rnorm(input$n, input$mean, input$sigma)) %&gt;%
      ggplot() +
        geom_histogram(aes(values), bins = 100) +
        xlim(-10, 10)
  })

  output$dt &lt;- renderDataTable({
    data.frame(values = rnorm(input$n, input$mean, input$sigma))
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/15f7837a-64b6-4f73-9b4a-13f2ca168daa/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
  <li>
    <p>The issue is that this code reruns <code class="language-plaintext highlighter-rouge">rnorm</code> for each output. So, even
though the interfaces suggests that the printed samples are the same
as the ones in the histogram, they are actually different. To
resolve this, we need a way of storing an intermediate computation
which (1) depends on the inputs but (2) feeds into several outputs.
Whenever we encounter this need, we can use a reactive expression.
It is a type of server element that depends on the input and can be
referred to directly by outputs, which call the reactive expression
like a function. For example, the code below generates the random
normal samples a single time, using the <code class="language-plaintext highlighter-rouge">samples()</code> reactive
expression.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    data.frame(values = rnorm(input$n, input$mean, input$sigma))
  })

  output$histogram &lt;- renderPlot({
      ggplot(samples()) +
        geom_histogram(aes(values), bins = 100) +
        xlim(-10, 10)
  })

  output$dt &lt;- renderDataTable(samples())
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/3e53bb63-a19a-4ded-8ab6-5ffbc9447c8f/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
  <li>
    <p>Finally, a good practice is to move as much non-app related code to
separate functions. This makes the flow of the app more transparent.
The clearer the delineation between “computation required for
individual app components” and “relationship across components,” the
easier the code will be to understand and extend.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

### Functions within app components
generate_data &lt;- function(n, mean, sigma) {
  data.frame(values = rnorm(n, mean, sigma))
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(aes(values), bins = 100) +
    xlim(-10, 10)
}

### Defines the app
ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(samples()))
  output$dt &lt;- renderDataTable(samples())
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/fe220e82-becf-4cc6-891c-7fa1c69ba850/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
</ol>

<p>[1] I like to use these names to keep everything organized, but they are
not official, and you do not need to memorize this.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Vocabulary used by R Shiny Library, and a few example apps.]]></summary></entry><entry><title type="html">Introduction to Reactivity</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week2-2.html" rel="alternate" type="text/html" title="Introduction to Reactivity" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week2-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week2-2.html"><![CDATA[<p><em>Viewing shiny code execution as a graph</em></p>

<ol>
  <li>
    <p>These notes will explore the idea of reactivity in more depth.
Recall that reactivity refers to the fact that Shiny app code is not
run from top to bottom, like an ordinary R script. Instead, it runs
reactively, depending on inputs that the user has provided. This can
make writing Shiny code a bit unintuitive at first, but there are a
few higher-level concepts that can help when writing reactive code.</p>
  </li>
  <li>
    <p>The most important of these concepts is that reactive code can be
viewed as a graph. The <code class="language-plaintext highlighter-rouge">ui</code> and <code class="language-plaintext highlighter-rouge">server</code> define an explicit
dependency structure for how components depend on one another. The
<code class="language-plaintext highlighter-rouge">input$</code>’s within <code class="language-plaintext highlighter-rouge">render*</code> functions in the server specify how UI
inputs affect server computations. The IDs within the <code class="language-plaintext highlighter-rouge">*Output</code>
elements in the <code class="language-plaintext highlighter-rouge">ui</code> specify which of the rendered <code class="language-plaintext highlighter-rouge">output$</code>’s in
the server should be used to populate the visible interface.</p>
  </li>
  <li>
    <p>For example, our first “Hello” app has the following (simple)
reactivity graph. Note that I’ve drawn input and output nodes
differently, to emphasize the flow of computation. I’ve also copied
the code from the original app for reference.</p>

    <p><img src="https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-02/figures/names.png" alt="" /></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello!"),
  textInput("name", "Enter your name"),
  textOutput("printed_name")
)

server &lt;- function(input, output) {
  output$printed_name &lt;- renderText({
    paste0("Welcome to shiny, ", input$name, "!")
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/43a4312c-a124-4b63-8228-23ba5375992b/" allowfullscreen="" data-external="1"></iframe>
  </li>
  <li>
    <p>Even though the graph is simple, note that the outputs will be
recomputed each time that the input is changed. For more general
graphs, all downstream nodes will be re-executed whenever an
upstream source is changed (typically by a user input, though it’s
possible to trigger changes automatically).</p>
  </li>
  <li>
    <p>Reactive expressions provide a special kind of node that live
between inputs and outputs. They depend on inputs, and they feed
into outputs, but they are never made directly visible to the user.
This is why we’ve drawn them as a kind of special intermediate node.
Below, I’ve drawn the graph for our random normal plotter, with the
reactive <code class="language-plaintext highlighter-rouge">samples()</code> expression.</p>

    <p><img src="https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-02/figures/reactive_histo.png" alt="" /></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)

### Functions within app components
generate_data &lt;- function(n, mean, sigma) {
  data.frame(values = rnorm(n, mean, sigma))
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(aes(values), bins = 100) +
    xlim(-10, 10)
}

### Defines the app
ui &lt;- fluidPage(
  titlePanel("Random Normals"),
  numericInput("mean", "Enter the mean", 0),
  sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
  sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
  plotOutput("histogram"),
  dataTableOutput("dt")
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(samples()))
  output$dt &lt;- renderDataTable(samples())
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/6063856c-2c50-4bb2-b272-b1c41b30f574/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
  <li>
    <p>A useful perspective is to think of reactive expressions as
simplifying the overall reactivity graph. Specifically, by adding a
reactive node, it’s possible to trim away many edges. For example,
our initial implementation of the random normal plotter (which
didn’t use the reactive expression) has a much more complicated
graph, since many inputs feed directly into outputs.</p>

    <p><img src="https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-02/figures/nonreactive_histo.png" alt="" /></p>
  </li>
  <li>
    <p>Let’s see these principles in action for a similar, but more complex
app. The app below can be used for power analysis. It simulates two
groups of samples, both from normal distributions, but with
different (user specified) means. We’ve used a reactive expression
to generate the samples, so that both the histogram and hypothesis
test result outputs can refer to the same intermediate simulated
data.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(broom)

### Functions within app components
generate_data &lt;- function(n, mean1, mean2, sigma) {
  data.frame(
    values = c(rnorm(n, mean1, sigma), rnorm(n, mean2, sigma)),
    group = rep(c("A", "B"), each = n)
  )
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(
      aes(values, fill = group), 
      bins = 100, position = "identity",
      alpha = 0.8
    ) +
    xlim(-10, 10)
}

test_fun &lt;- function(df) {
  t.test(values ~ group, data = df) %&gt;%
    tidy() %&gt;%
    select(p.value, conf.low, conf.high)
}

### Defines the app
ui &lt;- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("mean1", "Mean (Group 1)", 0, min = -10.0, max = 10.0, step = 0.1),
      sliderInput("mean2", "Mean (Group 2)", 0, min = -10, max = 10, step = 0.1),
      sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
      sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
    ),
    mainPanel(
      plotOutput("histogram"),
      dataTableOutput("test_result")
    )
  )
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean1, input$mean2, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(generate_data(input$n, input$mean1, input$mean2, input$sigma)))
  output$test_result &lt;- renderDataTable(test_fun(generate_data(input$n, input$mean1, input$mean2, input$sigma)))
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/1f5cecd2-a4c7-46bd-a2ea-07443b009687/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>

    <p>Other than that, the only difference is that I’ve saved output from
the <code class="language-plaintext highlighter-rouge">t.test</code> using <code class="language-plaintext highlighter-rouge">test_result</code>. Notice the use of the <code class="language-plaintext highlighter-rouge">broom</code>
package, which helps format the test output into a <code class="language-plaintext highlighter-rouge">data.frame</code>.</p>
  </li>
  <li>
    <p>So far, all of our reactive code has lived within the <code class="language-plaintext highlighter-rouge">render*</code> or
<code class="language-plaintext highlighter-rouge">reactive()</code> sets of functions. However, there is a another kind
that is often useful, especially in more advanced applications:
<code class="language-plaintext highlighter-rouge">observers</code>. An observer is a computation that is done every time
certain inputs are changed, but which don’t affect downstream UI
outputs through a <code class="language-plaintext highlighter-rouge">render*</code> function. For example, below, we’ve
added a block (under <code class="language-plaintext highlighter-rouge">observeEvent</code>) that prints to the console
every time either of the means are changed. I realize it is a bit of
a mystery why these functions would ever be useful, but we will see
them in more realistic contexts next week.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(broom)

### Functions within app components
generate_data &lt;- function(n, mean1, mean2, sigma) {
  data.frame(
    values = c(rnorm(n, mean1, sigma), rnorm(n, mean2, sigma)),
    group = rep(c("A", "B"), each = n)
  )
}

histogram_fun &lt;- function(df) {
  ggplot(df) +
    geom_histogram(
      aes(values, fill = group), 
      bins = 100, position = "identity",
      alpha = 0.8
    ) +
    xlim(-10, 10)
}

test_fun &lt;- function(df) {
  t.test(values ~ group, data = df) %&gt;%
    tidy() %&gt;%
    select(p.value, conf.low, conf.high)
}

### Defines the app
ui &lt;- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("mean1", "Mean (Group 1)", 0, min = -10.0, max = 10.0, step = 0.1),
      sliderInput("mean2", "Mean (Group 2)", 0, min = -10, max = 10, step = 0.1),
      sliderInput("sigma", "Enter the standard deviation", 1, min=.1, max=5),
      sliderInput("n", "Enter the number of samples", 500, min=1, max=2000),
    ),
    mainPanel(
      plotOutput("histogram"),
      dataTableOutput("test_result")
    )
  )
)

server &lt;- function(input, output) {
  samples &lt;- reactive({
    generate_data(input$n, input$mean1, input$mean2, input$sigma)
  })
  output$histogram &lt;- renderPlot(histogram_fun(samples()))
  output$test_result &lt;- renderDataTable(test_fun(samples()))
  observeEvent(input$mean1 | input$mean2, {
    message("group 1 mean is now: ", input$mean1)
    message("group 2 mean is now: ", input$mean2)
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/752b80de-5c75-4dd9-b7fe-2d399c3ea3da/" allowfullscreen="" data-external="1" height="935" width="600"></iframe>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Viewing shiny code execution as a graph]]></summary></entry><entry><title type="html">IMDB Shiny Application</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week2-3.html" rel="alternate" type="text/html" title="IMDB Shiny Application" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week2-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week2-3.html"><![CDATA[<p><em>Using Shiny to explore a movies dataset</em></p>

<ol>
  <li>
    <p>So far, all of our Shiny applications have been based on toy
simulated data. In this set of notes, we’ll use Shiny to explore a
real dataset, illustrating the general development workflow in the
process. Before diving into code, let’s consider the role of
interactivity in data analysis.</p>
  </li>
  <li>
    <p>A major difference between doing visualization on paper and on
computers is that visualization on computers can make use of
interactivity. An interactive visualization is one that changes in
response to user cues. This allows a display to update in a way that
provides a visual comparison that was not available in a previous
view. In this way, interactive visualization allows users to answer
a sequence of questions.</p>
  </li>
  <li>
    <p>Selection, both of observations and of attributes, is fundamental to
interactive visualization. This is because it precedes other
interactive operations: you can select a subset of observations to
filter down to or attributes to coordinate across multiple displays
(we consider both types of interactivity in later lectures).</p>
  </li>
  <li>
    <p>The code below selects movies to highlight based on Genre. We use a
<code class="language-plaintext highlighter-rouge">selectInput</code> to create the dropdown menu. A reactive expression
creates a new column (<code class="language-plaintext highlighter-rouge">selected</code>) in the <code class="language-plaintext highlighter-rouge">movies</code> dataset
specifiying whether the current movie is selected. The reactive
graph structure means that the ggplot2 figure is recreated each time
the selection is changed, and the <code class="language-plaintext highlighter-rouge">selected</code> column is used to shade
in the points. This process of changing the visual encoding of
graphical marks depending on user selections is called “conditional
encoding.”</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(lubridate)

movies &lt;- read_csv("https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv") %&gt;%
  mutate(
    date = as_date(Release_Date, format = "%b %d %Y"),
    year = year(date),
    Major_Genre = fct_explicit_na(Major_Genre),
    MPAA_Rating = fct_explicit_na(MPAA_Rating),
  )

genres &lt;- pull(movies, Major_Genre) %&gt;%
  unique() %&gt;%
  na.omit()

### functions used in app
scatterplot &lt;- function(df) {
  ggplot(df) +
    geom_point(
      aes(Rotten_Tomatoes_Rating, IMDB_Rating, size = selected, alpha = selected)
    ) +
    scale_size(limits = c(0, 1), range = c(.5, 2), guide = "none") +
    scale_alpha(limits = c(0, 1), range = c(.1, 1), guide = "none")
}

### definition of app
ui &lt;- fluidPage(
  titlePanel("IMDB Analysis"),
  selectInput("genres", "Genre", genres),
  plotOutput("ratings_scatter")
)

server &lt;- function(input, output) {
  movies_subset &lt;- reactive({
    movies %&gt;%
      mutate(selected = 1 * (Major_Genre %in% input$genres))
  })

  output$ratings_scatter &lt;- renderPlot({
    scatterplot(movies_subset())
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/02971f81-3af5-4fdb-89d7-84a663778546/" allowfullscreen="" data-external="1" height="550" width="600"></iframe>

    <p><img src="/https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/figures/initial_imdb.png" alt="" /></p>
  </li>
  <li>
    <p>We can extend this further. Let’s allow the user to filter by year
and MPAA rating. Notice that there are some years in the future! We
also find that there are systematic differences in IMDB and Rotten
Tomatoes ratings as a function of these variables.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(lubridate)

movies &lt;- read_csv("https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv") %&gt;%
  mutate(
    date = as_date(Release_Date, format = "%b %d %Y"),
    year = year(date),
    Major_Genre = fct_explicit_na(Major_Genre),
    MPAA_Rating = fct_explicit_na(MPAA_Rating),
  )

genres &lt;- pull(movies, Major_Genre) %&gt;%
  unique() %&gt;%
  na.omit()
ratings &lt;- pull(movies, MPAA_Rating) %&gt;%
  unique() %&gt;%
  na.omit()

### functions used in app
scatterplot &lt;- function(df) {
  ggplot(df) +
    geom_point(
      aes(Rotten_Tomatoes_Rating, IMDB_Rating, size = selected, alpha = selected)
    ) +
    scale_size(limits = c(0, 1), range = c(.5, 2), guide = "none") +
    scale_alpha(limits = c(0, 1), range = c(.1, 1), guide = "none")
}

### definition of app
ui &lt;- fluidPage(
  titlePanel("IMDB Analysis"),
  selectInput("genres", "Genre", genres, multiple = TRUE),
  checkboxGroupInput("mpaa", "MPAA Rating", ratings, ratings),
  sliderInput("year", "Year", min = min(movies$year), max = max(movies$year), c(1928, 2020), sep = ""),
  plotOutput("ratings_scatter")
)

server &lt;- function(input, output) {
  movies_subset &lt;- reactive({
    movies %&gt;%
      mutate(selected = 1 * (
        (Major_Genre %in% input$genres) &amp;
        (MPAA_Rating %in% input$mpaa) &amp;
        (year &gt;= input$year[1]) &amp;
        (year &lt;= input$year[2])
      ))
  })

  output$ratings_scatter &lt;- renderPlot({
    scatterplot(movies_subset())
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/9036974c-176a-4e9b-963d-c25eb45f5635/" allowfullscreen="" data-external="1" height="900" width="600"></iframe>

    <p><img src="/https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/figures/final_imdb.png" alt="" /></p>
  </li>
  <li>
    <p>We’ll include a final version of this plot which additionally shows
the movie name when points are hovered. To accomplish this, we can
no longer use <code class="language-plaintext highlighter-rouge">ggplot2</code> on its own – it has to be linked with a
plotting library that renders web-based visualizations (not just
static image files). This is what the <code class="language-plaintext highlighter-rouge">ggplotly()</code> call does in the
updated version of the app. The mouseover text is added through the
<code class="language-plaintext highlighter-rouge">tooltip</code> argument.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(shiny)
library(tidyverse)
library(lubridate)
library(plotly)

movies &lt;- read_csv("https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv") %&gt;%
  mutate(
    date = as_date(Release_Date, format = "%b %d %Y"),
    year = year(date),
    Major_Genre = fct_explicit_na(Major_Genre),
    MPAA_Rating = fct_explicit_na(MPAA_Rating),
  )

genres &lt;- pull(movies, Major_Genre) %&gt;%
  unique() %&gt;%
  na.omit()
ratings &lt;- pull(movies, MPAA_Rating) %&gt;%
  unique() %&gt;%
  na.omit()

### functions used in app
scatterplot &lt;- function(df) {
  p &lt;- ggplot(mapping = aes(Rotten_Tomatoes_Rating, IMDB_Rating)) +
    geom_point(data = df %&gt;% filter(selected),  aes(text = Title), size = 2, alpha = 1) +
    geom_point(data = df %&gt;% filter(!selected),  size = .5, alpha = .1)
  ggplotly(p, tooltip = "Title") %&gt;%
    style(hoveron = "fill")
}

### definition of app
ui &lt;- fluidPage(
  titlePanel("IMDB Analysis"),
  selectInput("genres", "Genre", genres),
  checkboxGroupInput("mpaa", "MPAA Rating", ratings, ratings),
  sliderInput("year", "Year", min = min(movies$year), max = max(movies$year), c(1928, 2020), sep = ""),
  plotlyOutput("ratings_scatter")
)

server &lt;- function(input, output) {
  movies_subset &lt;- reactive({
    movies %&gt;%
      mutate(selected = (
        (Major_Genre %in% input$genres) &amp;
        (MPAA_Rating %in% input$mpaa) &amp;
        (year &gt;= input$year[1]) &amp;
        (year &lt;= input$year[2])
      ))
  })

  output$ratings_scatter &lt;- renderPlotly({
    scatterplot(movies_subset())
  })
}

app &lt;- shinyApp(ui, server)
</code></pre></div>    </div>

    <iframe src="https://data-viz.it.wisc.edu/content/2151742d-4b80-4200-9b91-55dda592a9f6/" allowfullscreen="" data-external="1" height="900" width="600"></iframe>
  </li>
  <li>
    <p>These visualizations are an instance of the more general idea of
using filtering to reduce complexity in data. Filtering is an
especially powerful technique in the interactive paradigm, where it
is possible to easily reverse (or compare) filtering choices.</p>
  </li>
  <li>
    <p>Conceptually, what we are doing falls under the name of “Dynamic
Querying,” which refers more generally to updating a visualization
based on user queries. There are several ways to think about these
dynamic queries,</p>

    <ul>
      <li>Interpretation 1: Dynamic queries create the visual analog of a
database interaction. Rather than using a programming-based
interface to filter elements or select attributes, we can design
interactive visual equivalents.</li>
      <li>Interpretation 2: Dynamic queries allow rapid evaluation of
conditional probabilities. The visualization above was designed
to answer: What is the joint distribution of movie ratings,
conditional on being a drama?</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Using Shiny to explore a movies dataset]]></summary></entry><entry><title type="html">Graphical Queries - Click Events</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week3-1.html" rel="alternate" type="text/html" title="Graphical Queries - Click Events" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week3-1</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week3-1.html"><![CDATA[<p><em>An introduction to click events in Shiny</em></p>

<ol>
  <li>
    <p>Some of the most sophisticated interactive data visualizations are
based on the idea that user queries can themselves be defined
visually. For example, to select a date range, we could directly
interact with a time series plot, rather than relying on a slider
input. Or, instead of a long dropdown menu of items, a user could
select items by clicking on bars in a bar plot. There are many
variations of this idea, but they all leverage graphical (rather
than textual) displays to define queries. The advantage of this
approach is that it increases information density – the selection
inputs themselves encode data.</p>
  </li>
  <li>
    <p>To implement this in Shiny, we first need a way of registering user
interactions on plots themselves. We will consider two types of plot
interaction mechanisms: clicks and brushes. These can be specified
by adding <code class="language-plaintext highlighter-rouge">click</code> or <code class="language-plaintext highlighter-rouge">brush</code> events to <code class="language-plaintext highlighter-rouge">plotOutput</code> objects.</p>
  </li>
  <li>
    <p>This creates a UI with a single plot on which we will be able to
track user clicks,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ui &lt;- fluidPage(
  plotOutput("plot", click = "plot_click")
)
</code></pre></div>    </div>

    <p>Here, <code class="language-plaintext highlighter-rouge">plot_click</code> is an ID that can be used as <code class="language-plaintext highlighter-rouge">input$plot_click</code>
in the server. We could name it however we want, but we need to be
consistent across the UI and server (just like ordinary,
non-graphical inputs).</p>
  </li>
  <li>
    <p>Before, we just needed to place the <code class="language-plaintext highlighter-rouge">input$id</code> items within <code class="language-plaintext highlighter-rouge">render</code>
and <code class="language-plaintext highlighter-rouge">reactive</code> server components, and the associated outputs would
automatically know to redraw each time the value of any input was
changed. Clicks are treated slightly differently. We have to
both (a) recognize when a click event has occurred and (b) extract
relevant information about what the click was referring to.</p>
  </li>
  <li>
    <p>For (a), we generally use <code class="language-plaintext highlighter-rouge">observeEvent</code>,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>observeEvent(
  input$plot_click,
  ... things to do when the plot is clicked ...
)
</code></pre></div>    </div>

    <p>This piece of code will be run anytime the plot is clicked.</p>
  </li>
  <li>
    <p>For (b), we can use the <code class="language-plaintext highlighter-rouge">nearPoints</code> helper function. Suppose the
plot was made using the data.frame <code class="language-plaintext highlighter-rouge">x</code>. Then</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nearPoints(x, input$click)
</code></pre></div>    </div>

    <p>will return the samples in <code class="language-plaintext highlighter-rouge">x</code> that are close to the clicked
location. We will often use a variant of this code that doesn’t just
return the closeby samples – it returns all samples, along with
their distance from the clicked location,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nearPoints(x, input$click, allRows = TRUE, addDist = TRUE)
</code></pre></div>    </div>
  </li>
  <li>
    <p>We are almost ready to build a visualization whose outputs respond
to graphical queries. Suppose we want a scatterplot where point
sizes update according to their distance from the user’s click.
Everytime the plot is clicked, we need to update the set of
distances between samples and the clicked point. We then need to
rerender the plot to reflect the new distances. This logic is
captured by the block below,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server &lt;- function(input, output) {
  dist &lt;- reactiveVal(rep(1, nrow(x)))
  observeEvent(
    input$plot_click,
    dist(reset_dist(x, input$plot_click))
  )

  output$plot &lt;- renderPlot({
    scatter(x, dist())
  })
}
</code></pre></div>    </div>

    <p>The code above uses one new concept, the <code class="language-plaintext highlighter-rouge">reactiveVal</code> on the first
line of the function. It is a variable that doesn’t directly depend
on any inputs, which can become a source node for downstream
<code class="language-plaintext highlighter-rouge">reactive</code> and <code class="language-plaintext highlighter-rouge">render</code> nodes in the reactive graph. Anytime the
variable’s value is changed, all downstream nodes will be
recomputed. A very common pattern is use an <code class="language-plaintext highlighter-rouge">observeEvent</code> to update
a <code class="language-plaintext highlighter-rouge">reactiveVal</code> every time a graphical query is performed. Any plots
that depend on this value will then be updated. For example,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val &lt;- reactiveVal(initial_val) # initialize the reactive value

observeEvent(
  ...some input event...
  ...do some computation...
  val(new_value) # update val to new_val
)

# runs each time the reactiveVal changes
renderPlot({
  val() # get the current value of the reactive value
})
</code></pre></div>    </div>
  </li>
  <li>
    <p>So, revisiting the <code class="language-plaintext highlighter-rouge">dist</code> in the earlier code block, we see that it
is initialized as a vector of <code class="language-plaintext highlighter-rouge">1</code>’s whose length is equal to the
number of rows of <code class="language-plaintext highlighter-rouge">x</code>. Everytime the plot is clicked, we update the
value of <code class="language-plaintext highlighter-rouge">dist</code> according to the function <code class="language-plaintext highlighter-rouge">reset_dist</code>. Finally, the
changed value of <code class="language-plaintext highlighter-rouge">dist</code> triggers a rerun of <code class="language-plaintext highlighter-rouge">renderPlot</code>. Let’s look
at the full application in action. It makes a scatterplot using the
cars dataset and resizes points every time the plot is clicked.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(shiny)

# wrapper to get the distances from points to clicks
reset_dist &lt;- function(x, click) {
  nearPoints(x, click, allRows = TRUE, addDist = TRUE)$dist_
}

# scatterplot plot with point size dependent on click location
scatter &lt;- function(x, dists) {
  x %&gt;%
    mutate(dist = dists) %&gt;%
    ggplot() +
    geom_point(aes(mpg, hp, size = dist)) +
    scale_size(range = c(6, 1))
}

ui &lt;- fluidPage(
  plotOutput("plot", click = "plot_click")
)

server &lt;- function(input, output) {
  dist &lt;- reactiveVal(rep(1, nrow(mtcars)))
  observeEvent(
    input$plot_click,
    dist(reset_dist(mtcars, input$plot_click))
  )

  output$plot &lt;- renderPlot(scatter(mtcars, dist()))
}

shinyApp(ui, server)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week3-1/unnamed-chunk-8-1.png" alt="" /></p>

    <iframe src="https://data-viz.it.wisc.edu/content/17a54e4c-5237-4018-b6fe-20c1555cf337/" allowfullscreen="" data-external="1" height="400" width="600"></iframe>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">reset_dist</code> function uses <code class="language-plaintext highlighter-rouge">nearPoints</code> to compute the distance
between each sample and the plot, each time the plot is clicked. The
associated reactive value <code class="language-plaintext highlighter-rouge">dist</code> gets changed, which triggers
<code class="language-plaintext highlighter-rouge">scatterplot</code> to run, and it is encoded using size in the downstream
ggplot2 figure.</p>
  </li>
  <li>
    <p>We can make the plot more interesting by outputting a table showing
the original dataset. Using the same <code class="language-plaintext highlighter-rouge">dist()</code> call, we can sort the
table by distance each time the plot is clicked.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(shiny)
mtcars &lt;- add_rownames(mtcars)

reset_dist &lt;- function(x, click) {
  nearPoints(x, click, allRows = TRUE, addDist = TRUE)$dist_
}

scatter &lt;- function(x, dists) {
  x %&gt;%
    mutate(dist = dists) %&gt;%
    ggplot() +
    geom_point(aes(mpg, hp, size = dist)) +
    scale_size(range = c(6, 1))
}

ui &lt;- fluidPage(
  plotOutput("plot", click = "plot_click"),
  dataTableOutput("table")
)

server &lt;- function(input, output) {
  dist &lt;- reactiveVal(rep(1, nrow(mtcars)))
  observeEvent(
    input$plot_click,
    dist(reset_dist(mtcars, input$plot_click))
  )

  output$plot &lt;- renderPlot(scatter(mtcars, dist()))
  output$table &lt;- renderDataTable({
    mtcars %&gt;%
      mutate(dist = dist()) %&gt;%
      arrange(dist)
  })
}

shinyApp(ui, server)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week3-1/unnamed-chunk-9-1.png" alt="" /></p>

    <iframe src="https://data-viz.it.wisc.edu/content/9fcf3583-a74f-4d84-8d7c-68ac3595bf6b/" allowfullscreen="" data-external="1" height="750" width="800"></iframe>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[An introduction to click events in Shiny]]></summary></entry><entry><title type="html">Graphical Queries - Brush Events</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week3-2.html" rel="alternate" type="text/html" title="Graphical Queries - Brush Events" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week3-2</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week3-2.html"><![CDATA[<p><strong>An introduction to brush events in Shiny</strong></p>

<ol>
  <li>
    <p>Click events are useful for referring to individual samples.
However, they are not ideal for referring to groups of samples. In
this case, a useful type of plot input is a <code class="language-plaintext highlighter-rouge">brush</code>. This is a
selection that can be defined by clicking and dragging over a
region.</p>
  </li>
  <li>
    <p>In shiny, brush events are treated similarly to click events. For
example, to define a new brush input, we can set the <code class="language-plaintext highlighter-rouge">brush</code>
argument to <code class="language-plaintext highlighter-rouge">plotOutput</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ui &lt;- fluidPage(
  plotOutput("plot", brush = "plot_brush")
)
</code></pre></div>    </div>

    <p>Just like the <code class="language-plaintext highlighter-rouge">click</code> argument, the value <code class="language-plaintext highlighter-rouge">"plot_brush"</code> is an ID
that can be used in the server. Also like in click events, we can
setup an observer to change a reactive value every time a brush is
drawn[1]. The general pattern is similar to what we had before,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server &lt;- function(input, output) {
  selected &lt;- reactiveVal(initial value)
  observeEvent(
    input$plot_brush,
    ... computation using get new_value ...
    selected(new_value)
  )

  output$plot &lt;- renderPlot(... use scatter() reactive val...)
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>The example below is similar to the <code class="language-plaintext highlighter-rouge">plot_click</code> example from the
previous notes. Instead of sorting points by proximity to the click,
though, prints the subset of rows that have been currently brushed.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(shiny)
mtcars &lt;- add_rownames(mtcars)

reset_selection &lt;- function(x, brush) {
  brushedPoints(x, brush, allRows = TRUE)$selected_
}

scatter &lt;- function(x, selected_) {
  x %&gt;%
    mutate(selected_ = selected_) %&gt;%
    ggplot() +
    geom_point(aes(mpg, hp, alpha = as.numeric(selected_))) +
    scale_alpha(range = c(0.1, 1))
}

ui &lt;- fluidPage(
  plotOutput("plot", brush = "plot_brush"),
  dataTableOutput("table")
)

server &lt;- function(input, output) {
  selected &lt;- reactiveVal(rep(TRUE, nrow(mtcars)))
  observeEvent(
    input$plot_brush,
    selected(reset_selection(mtcars, input$plot_brush))
  )

  output$plot &lt;- renderPlot(scatter(mtcars, selected()))
  output$table &lt;- renderDataTable(filter(mtcars, selected()))
}

shinyApp(ui, server)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week3-2/unnamed-chunk-4-1.png" alt="" /></p>

    <iframe src="https://data-viz.it.wisc.edu/content/a651bc7b-6773-445d-8bc6-22084155e21a/" allowfullscreen="" data-external="1" height="700" width="600"></iframe>
  </li>
  <li>
    <p>It is often useful to combine multi-view composition (<em>i.e.</em>,
faceting or compound figures) with dynamic queries. The basic idea
is to (a) show different aspects of a dataset using different views,
and then (b) link the views using dynamic queries. This strategy is
sometimes called dynamic linking.</p>
  </li>
  <li>
    <p>The example below implements dynamic linking with the penguins
dataset. Brushing over either scatterplot highlights the
corresponding points in the adjacent plot (it also updates the data
table). This is a way of understanding structure beyond two
dimensions. The implementation is similar to the brushing above,
except that the reactive value <code class="language-plaintext highlighter-rouge">selected()</code> is called in two
<code class="language-plaintext highlighter-rouge">renderPlot</code> contexts, leading to changes in both plots every time
the brush is moved.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(shiny)
penguins &lt;- read_csv("https://uwmadison.box.com/shared/static/ijh7iipc9ect1jf0z8qa2n3j7dgem1gh.csv")

reset_selection &lt;- function(x, brush) {
  brushedPoints(x, brush, allRows = TRUE)$selected_
}

scatter &lt;- function(x, selected_, var1, var2) {
  x %&gt;%
    mutate(selected_ = selected_) %&gt;%
    ggplot(aes_string(var1, var2)) +
    geom_point(aes(alpha = as.numeric(selected_), col = species)) +
    scale_alpha(range = c(0.1, 1))
}

ui &lt;- fluidPage(
  fluidRow(
    column(6, plotOutput("scatter1", brush = "plot_brush")),
    column(6, plotOutput("scatter2", brush = "plot_brush"))
  ),
  dataTableOutput("table")
)

server &lt;- function(input, output) {
  selected &lt;- reactiveVal(rep(TRUE, nrow(penguins)))
  observeEvent(
    input$plot_brush,
    selected(reset_selection(penguins, input$plot_brush))
  )

  output$scatter1 &lt;- renderPlot({
    scatter(penguins, selected(), "bill_length_mm", "bill_depth_mm")
  })
  output$scatter2 &lt;- renderPlot({
    scatter(penguins, selected(), "flipper_length_mm", "body_mass_g")
  })

  output$table &lt;- renderDataTable(filter(penguins, selected()))
}

shinyApp(ui, server)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week3-2/unnamed-chunk-5-1.png" alt="" /></p>

    <iframe src="https://data-viz.it.wisc.edu/content/8e4b07a5-d671-40cb-9d57-22d25533b8fe/" allowfullscreen="" data-external="1" height="800" width="600"></iframe>
  </li>
</ol>

<p>[1] Technically, the code only executes when the mouse lifts off the
brush selection. Some visualizations will be able to call the updating
code every time the mouse is moved with the brush selected. This creates
a smoother experience.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[An introduction to brush events in Shiny]]></summary></entry><entry><title type="html">Shiny Layouts and Customization</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week3-3.html" rel="alternate" type="text/html" title="Shiny Layouts and Customization" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week3-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week3-3.html"><![CDATA[<p><em>More flexible designs in Shiny</em></p>]]></content><author><name></name></author><summary type="html"><![CDATA[More flexible designs in Shiny]]></summary></entry></feed>