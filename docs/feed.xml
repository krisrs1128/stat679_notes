<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/stat679_notes/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/stat679_notes/" rel="alternate" type="text/html" /><updated>2022-06-02T13:50:19-05:00</updated><id>http://localhost:4000/stat679_notes/feed.xml</id><title type="html">Statistical Data Visualization</title><subtitle>These are notes from STAT 679 (Fall 2022) at UW Madison.</subtitle><entry><title type="html">Introduction to ggplot2</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-1.html" rel="alternate" type="text/html" title="Introduction to ggplot2" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-1</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-1.html"><![CDATA[<p><em>Design principles from the grammar of graphics.</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(ggrepel)
library(scales)
library(dslabs)
</code></pre></div></div>

<ol>
  <li>
    <p>ggplot2 is an R implementation of the Grammar of Graphics. The idea
is to define the basic “words” from which visualizations are built,
and then let users compose them in original ways. This is in
contrast to systems with prespecified chart types, where the user is
forced to pick from a limited dropdown menu of plots. Just like in
ordinary language, the creative combination of simple building
blocks can support a very wide range of expression.</p>
  </li>
  <li>
    <p>We’re going to create this plot in these notes.</p>
  </li>
  <li>
    <p>Every ggplot2 plot is made from three components,</p>

    <ul>
      <li>Data: This is the data.frame that we want to visualize.</li>
      <li>Geometry: These are the types of visual marks that appear on the
plot.</li>
      <li>Aesthetic Mapping: This links the data with the visual marks.</li>
    </ul>
  </li>
  <li>
    <p><strong>Data</strong>. Each row is an observation, and each column is an
attribute that describes the observation. This is important because
each mark that you see on a ggplot – a line, a point, a tile, … –
had to start out as a row within an R data.frame. The visual
properties of the mark (e.g., color) are determined by the values
along columns. These type of data are often referred to as tidy
data.</p>
  </li>
  <li>
    <p>Here’s an example of the data above in tidy format,</p>

    <p>This is one example of how the same information might be stored in a
non-tidy way, making visualization much harder.</p>

    <p>Often, one of the hardest parts in making a ggplot2 plot is not
coming up with the right ggplot2 commands, but reshaping the data so
that it’s in a tidy format.</p>
  </li>
  <li>
    <p><strong>Geometry</strong> The words in the grammar of graphics are the geometry
layers. We can associate each row of a data frame with points,
lines, tiles, etc., just by referring to the appropriate geom in
ggplot2. A typical plot will compose a chain of layers on top of a
dataset,</p>
  </li>
</ol>

<!-- -->

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ggplot(data) + [layer 1] + [layer 2] + …
</code></pre></div></div>

<ol>
  <li>
    <p>For example, by deconstructing the plot above, we would expect to
have point and text layers. For now, let’s just tell the plot to put
all the geom’s at the origin. You can see all the types of geoms in
the cheat sheet. We’ll be experimenting with a few of these in a
later lecture.</p>
  </li>
  <li>
    <p><strong>Aesthetic Mapping</strong> Aesthetic mappings make the connection between
the data and the geometry. It’s the piece that translates abstract
data fields into visual properties. Analyzing the original graph, we
recognize these specific mappings.</p>

    <ul>
      <li>State Population → x-axis coordinate</li>
      <li>Number of murders → y-axis coordinate</li>
      <li>Geographical region → color</li>
    </ul>
  </li>
  <li>
    <p>To establish these mappings, we need to use the aes function. Notice
that column names don’t have to be quoted – ggplot2 knows to refer
back to the data.frame in ggplot(murders).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(murders) +
  geom_point(aes(x = population, y = total, col = region))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-2/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p>The original plot used a log-scale. To transform the x and y axes,
we can use scales.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(murders) +
  geom_point(aes(x = population, y = total, col = region)) +
  scale_x_log10() +
  scale_y_log10()
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-2/unnamed-chunk-4-1.png" alt="" /></p>

    <p>One nuance is that scales aren’t limited to x and y transformations.
They can be applied to modify any relationship between a data field
and its appearance on the page. For example, this changes the
mapping between the region field and circle color.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(murders) +
  geom_point(aes(x = population, y = total, col = region)) +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = c("#6a4078", "#aa1518", "#9ecaf8", "#50838c"))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-2/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>A problem with this graph is that it doesn’t tell us which state
each point corresponds to. For that, we’ll need text labels. We can
encode the coordinates for these marks again using aes, but this
time within a <code class="language-plaintext highlighter-rouge">geom_text</code> layer.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(murders) +
  geom_point(aes(x = population, y = total, col = region)) +
  geom_text(
    aes(x = population, y = total, label = abb),
    nudge_x = 0.08 # what would happen if I remove this?
  ) +
  scale_x_log10() +
  scale_y_log10()
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-2/unnamed-chunk-6-1.png" alt="" /></p>

    <p>Note that each type of layer uses different visual properties to
encode the data – the argument label is only available for the
<code class="language-plaintext highlighter-rouge">geom_text</code> layer. You can see which aesthetic mappings are required
for each type of geom by checking that geom’s documentation page,
under the Aesthetics heading.</p>
  </li>
  <li>
    <p>It’s usually a good thing to make your code as concise as possible.
For ggplot2, we can achieve this by sharing elements across aes
calls (e.g., not having to type population and total twice). This
can be done by defining a “global” aesthetic, putting it inside the
initial ggplot call. We can also use the fact that the first two
arguments of <code class="language-plaintext highlighter-rouge">aes</code> are always the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> positional mappings.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(murders, aes(population, total)) +
  geom_point(aes(col = region)) +
  geom_text(aes(label = abb), nudge_x = 0.08) +
  scale_x_log10() +
  scale_y_log10()
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-2/unnamed-chunk-7-1.png" alt="" /></p>
  </li>
  <li>
    <p>How can we improve the readability of this plot? You might already
have ideas,</p>

    <ul>
      <li>Prevent labels from overlapping. It’s impossible to read some of
the state names.</li>
      <li>Add a line showing the national rate. This serves as a point of
reference, allowing us to see whether an individual state is
above or below the national murder rate.</li>
      <li>Give meaningful axis / legend labels and a title.</li>
      <li>Move the legend to the top of the figure. Right now, we’re
wasting a lot of visual real estate in the right hand side, just
to let people know what each color means.</li>
      <li>Use a better color theme.</li>
    </ul>
  </li>
  <li>
    <p>For each of the problems above, we have the corresponding solution
techniques,</p>

    <ul>
      <li>The ggrepel package. This tries to find better label positions,
using lines when necessary.</li>
      <li>Use <code class="language-plaintext highlighter-rouge">geom_abline</code> to encode the national murder rate as the
slope and intercept in a line graph. All states would lie on
this line if their murder rate was equal to the national
average.</li>
      <li>Add a labs layer to write labels and a theme to reposition the
legend. I used <code class="language-plaintext highlighter-rouge">label_number</code> from the scales package to change
the scientific notation in the <em>x</em>-axis labels to something more
readable.</li>
      <li>I find the gray background with reference lines a bit
distracting. We can simplify the appearance using
<code class="language-plaintext highlighter-rouge">theme_minimal</code>. I also like the colorbrewer palette, which can
be used by calling a different color scale.</li>
    </ul>
  </li>
  <li>
    <p>Putting all these modifications together yields</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r &lt;- murders %&gt;%
  summarize(rate = sum(total) /  sum(population)) %&gt;%
  pull(rate)

ggplot(murders, aes(population, total)) +
  geom_abline(intercept = log10(r), size = 0.4, col = "#b3b3b3") +
  geom_text_repel(aes(label = abb), segment.size = 0.2) +
  geom_point(aes(col = region)) +
  scale_x_log10(labels = label_number(scale_cut = cut_short_scale())) +
  scale_y_log10() +
  scale_color_brewer(palette = "Set2") +
  labs(
    x = "Population (log scale)",
    y = "Total number of murders (log scale)",
    color = "Region",
    title = "US Gun Murders in 2010"
  ) +
  theme_minimal()
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-2/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Design principles from the grammar of graphics.]]></summary></entry><entry><title type="html">A Vocabulary of Marks</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-3.html" rel="alternate" type="text/html" title="A Vocabulary of Marks" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-3</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-3.html"><![CDATA[<p><em>Encoding options in ggplot2</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(tidyverse)
library(scales)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>The choice of encodings influences (1) the types of comparisons that
a visualization suggests and (2) the accuracy of the conclusions
that readers leave with. With this in mind, it’s in our best
interest to build a rich vocabulary of potential visual encodings.
The more kinds of marks and encodings that are at your fingertips,
the better your chances are that you’ll arrive at a configuration
that helps you achieve your purpose.</p>
  </li>
  <li>
    <p><strong>Point marks</strong> can encode data fields using their x and y
positions, color, size, and shape. Below, each mark is a country,
and we’re using shape and the y position to distinguish between
country clusters.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gapminder &lt;- read_csv("https://uwmadison.box.com/shared/static/dyz0qohqvgake2ghm4ngupbltkzpqb7t.csv", col_types = cols()) %&gt;%
  mutate(cluster = as.factor(cluster)) # specify that cluster is nominal
gap2000 &lt;- gapminder %&gt;%
  filter(year == 2000) # keep only year 2000
    ggplot(gap2000) +
      geom_point(aes(x = fertility, y = cluster, shape = cluster))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Bar marks</strong> Bar marks let us associate a continuous field with a
nominal one.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(gap2000) +
  geom_col(aes(country, pop))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-4-1.png" alt="" /></p>
  </li>
  <li>
    <p>This plot can be improved. The grid lines and tick marks associated
with each bar are distracting and the axis labels are all running
over one another. We resolve this by changing the theme and turning
the bars on their side[1]</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(gap2000) +
      geom_col(aes(pop, country)) +
      theme(
        panel.grid.major.y = element_blank(),
        axis.ticks = element_blank() # remove tick marks
      )
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>To make comparisons between countries with similar populations
easier, we can order them by population (alphabetical ordering is
not that meaningful). To compare clusters, we can color in the bars.</p>
  </li>
  <li>
    <p>We’ve been spending a lot of time on this plot. This is because I
want to emphasize that a visualization is not just something we can
get just by memorizing some magic (programming) incantation.
Instead, it is something worth critically engaging with and
refining, in a similar way that we would refine an essay or speech.
Philosophy aside, there are still a few points that need to be
improved in this figure,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> * The axis titles are not meaningful.
 * There is a strange gap between the left hand edge of the plot and the start of the bars.
 * I would also prefer if the bars were exactly touching one another, without the small vertical gap.
 * The scientific notation for population size is unnecessarily technical.
 * The color scheme is a bit boring^[.
</code></pre></div>    </div>
  </li>
  <li>
    <p>I’ve addressed each issue in the block below. Can you tell which
piece of code makes which change? Try removing different components
to verify your guesses.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cols &lt;- c("#80BFA2", "#7EB6D9", "#3E428C", "#D98BB6", "#BF2E21", "#F23A29")
    ggplot(gap2000) +
       geom_col(
         aes(pop, reorder(country, pop), fill = cluster),
         width = 1
       ) +
       scale_x_continuous(label = label_number_si(), expand = c(0, 0, 0.1, 0.1)) +
       scale_fill_manual(values = cols) +
       labs(x = "Population", y = "Country", fill = "Country Group", color = "Country Group") +
       theme(
         axis.ticks = element_blank(),
         panel.grid.major.y = element_blank()
       )
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-6-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Segment marks</strong>. In the plot above, each bar is anchored at 0.
Instead, we could have each bar encode two continuous values, a left
and right. To illustrate, let’s compare the minimum and maximimum
life expectancies within each country cluster. We’ll need to create
a new data.frame with just the summary information. For this, we
<code class="language-plaintext highlighter-rouge">group_by</code> each cluster, so that a summarise call finds the minimum
and maximum life expectancies restricted to each cluster.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># find summary statistics
life_ranges &lt;- gap2000 %&gt;%
  group_by(cluster) %&gt;%
  summarise(
    min_life = min(life_expect),
    max_life = max(life_expect)
  )

ggplot(life_ranges) +
  geom_segment(
    aes(min_life, reorder(cluster, max_life), xend = max_life, yend = cluster, col = cluster),
    size = 5,
  ) +
  scale_color_manual(values = cols) +
  labs(x = "Minimum and Maximum Expected Span", col = "Country Group", y = "Country Group") +
  xlim(0, 85) # otherwise would only range from 42 to 82
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-7-1.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Line marks</strong> are useful for comparing changes. Our eyes naturally
focus on rates of change when we see lines. Below, we’ll plot the
fertility over time, colored in by country cluster. The group
argument is useful for ensuring each country gets its own line; if
we removed it, ggplot2 would become confused by the fact that the
same x (year) values are associated with multiple y’s (fertility
rates).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(gapminder) +
      geom_line(
        aes(year, fertility, col = cluster, group = country),
          alpha = 0.7, size = 0.9
      ) +
      scale_x_continuous(expand = c(0, 0)) +  # same trick of removing gap
      scale_color_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
  <li>
    <p>Area marks have a flavor of both bar and line marks. The filled area
supports absolute comparisons, while the changes in shape suggest
derivatives.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_sums &lt;- gapminder %&gt;%
  group_by(year, cluster) %&gt;%
  summarise(total_pop = sum(pop))

ggplot(population_sums) +
  geom_area(aes(year, total_pop, fill = cluster)) +
  scale_y_continuous(expand = c(0, 0, .1, .1), label = label_number(cut_short_scale())) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-9-1.png" alt="" /></p>
  </li>
  <li>
    <p>Just like in bar marks, we don’t necessarily need to anchor the
y-axis at 0. For example, here the bottom and top of each area mark
is given by the 30% and 70% quantiles of population within each
country cluster.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_ranges &lt;- gapminder %&gt;%
  group_by(year, cluster) %&gt;%
  summarise(min_pop = quantile(pop, 0.3), max_pop = quantile(pop, 0.7))

ggplot(population_ranges) +
  geom_ribbon(
    aes(x = year, ymin = min_pop, ymax = max_pop, fill = cluster),
    alpha = 0.8
  ) +
  scale_y_continuous(expand = c(0, 0, .1, .1), label = label_number_si()) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = cols)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-3/unnamed-chunk-10-1.png" alt="" /></p>
  </li>
</ol>

<p>[1] An alternative is to turn rotate the labels by 90 degrees. I prefer
to turn the whole plot this, because this way, readers don’t have to
tilt their heads to read the country names.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Encoding options in ggplot2]]></summary></entry><entry><title type="html">Small Multiples and Faceting</title><link href="http://localhost:4000/stat679_notes/2022/06/01/week1-4.html" rel="alternate" type="text/html" title="Small Multiples and Faceting" /><published>2022-06-01T00:00:00-05:00</published><updated>2022-06-01T00:00:00-05:00</updated><id>http://localhost:4000/stat679_notes/2022/06/01/week1-4</id><content type="html" xml:base="http://localhost:4000/stat679_notes/2022/06/01/week1-4.html"><![CDATA[<p><em>Increased information density through faceting</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(dslabs)
library(tidyverse)
theme_set(theme_minimal())
</code></pre></div></div>

<ol>
  <li>
    <p>It might seem like we’re limited with the total number of variables
we can display at a time. While there are many types of encodings we
could in theory use, only a few them are very effective, and they
can interfere with one another.</p>
  </li>
  <li>
    <p>Not all is lost, though! A very useful idea for visualizing
high-dimensional data is the idea of small multiples. It turns out
that our eyes are pretty good at making sense of many small plots,
as long as there is some shared structure across the plots.</p>

    <p><img src="https://krisrs1128.github.io/stat479/posts/2021-01-20-week2-1/assets/sparklines.png" alt="" /></p>
  </li>
  <li>
    <p>In ggplot2, we can implement this idea using the <code class="language-plaintext highlighter-rouge">facet_wrap</code> and
<code class="language-plaintext highlighter-rouge">facet_grid</code> commands. We specify the column in the data.frame along
which we want to generate comparable small multiples.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>years &lt;- c(1962, 1980, 1990, 2000, 2012)
continents &lt;- c("Europe", "Asia")
gapminder_subset &lt;- gapminder %&gt;%
  filter(year %in% years, continent %in% continents)

ggplot(
    gapminder_subset, 
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(. ~ year) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-3-1.png" alt="" /></p>
  </li>
  <li>
    <p>In facet grid, you specify whether you want the plot to be repeated
across rows or columns, depending on whether you put the variable
before or after the tilde.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder_subset, 
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(year ~ .) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-4-1.png" alt="" /></p>
  </li>
  <li>
    <p>You can also facet by more than one variable at a time, specifying
which variables should go in rows and which should go in columns
again using the tilde.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder %&gt;% filter(year %in% years),
    aes(fertility, life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_grid(year ~ continent) +
  theme(legend.position = "bottom")
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-5-1.png" alt="" /></p>
  </li>
  <li>
    <p>Sometimes, you just want to see the display repeated over groups,
but you don’t really need them to all appear in the same row or
column. In this case, you can use <code class="language-plaintext highlighter-rouge">facet_wrap</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(
    gapminder %&gt;% filter(year %in% years),
    aes(x = fertility, y = life_expectancy, col = continent)
  ) +
  geom_point() +
  facet_wrap(~ year)
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-6-1.png" alt="" /></p>
  </li>
  <li>
    <p>Just to illustrate, faceting makes sense for datasets other than
scatterplots. This example also shows that faceting will apply to
multiple geom layers at once. The dataset below shows the abundances
of five different bacteria across three different subjects over
time, as they were subjected to antibiotics. The data were the basis
for [this study](&lt;)&gt;.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>antibiotic &lt;- read_csv("https://uwmadison.box.com/shared/static/5jmd9pku62291ek20lioevsw1c588ahx.csv")
head(antibiotic)

## # A tibble: 6 × 7
##   species  sample value ind    time svalue antibiotic     
##   &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          
## 1 Unc05qi6 D1         0 D         1   NA   Antibiotic-free
## 2 Unc05qi6 D2         0 D         2   NA   Antibiotic-free
## 3 Unc05qi6 D3         0 D         3    0   Antibiotic-free
## 4 Unc05qi6 D4         0 D         4    0   Antibiotic-free
## 5 Unc05qi6 D5         0 D         5    0   Antibiotic-free
## 6 Unc05qi6 D6         0 D         6    0.2 Antibiotic-free
</code></pre></div>    </div>
  </li>
  <li>
    <p>I have also separately computed running averages for each of the
variables – this is in the <code class="language-plaintext highlighter-rouge">svalue</code> column.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(antibiotic, aes(x = time)) +
      geom_line(aes(y = svalue), size = 1.2) +
      geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
      facet_grid(species ~ ind) +
      scale_color_brewer(palette = "Set2") +
      theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-8-1.png" alt="" /></p>
  </li>
  <li>
    <p>It seems like some of the species are much more abundant than
others. In this situation, it might make sense to rescale the
y-axis. Though, this is always a risky decision – people might
easily misinterpret the plot and conclude that the different species
all have the same abundances. Nonetheless, it can’t hurt to try,
using the scale argument to <code class="language-plaintext highlighter-rouge">facet_grid</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ggplot(antibiotic, aes(x = time)) +
      geom_line(aes(y = svalue), size = 1.2) +
      geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
      facet_grid(species ~ ind, scale = "free_y") +
      scale_color_brewer(palette = "Set2") +
      theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-9-1.png" alt="" /></p>
  </li>
  <li>
    <p>Unlike the years example, the facets don’t automatically come with
their own natural order. We can define an order based on the average
value of the responses over the course of the survey.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ggplot(antibiotic, aes(x = time)) +
  geom_line(aes(y = svalue), size = 1.2) +
  geom_point(aes(y = value, col = antibiotic), size = 0.5, alpha = 0.8) +
  facet_grid(reorder(species, value, mean) ~ ind, scale = "free_y") +
  scale_color_brewer(palette = "Set2") +
  theme(strip.text.y = element_text(angle = 0))
</code></pre></div>    </div>

    <p><img src="/stat679_notes/assets/week1-4/unnamed-chunk-10-1.png" alt="" /></p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Increased information density through faceting]]></summary></entry></feed>