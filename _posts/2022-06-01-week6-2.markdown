---
title: Click and Hover Interaction in D3 (Part 1)
layout: post
output:
  md_document:
    preserve_yaml: true
---

1. In the previous notes, we saw how user can supply interactions using D3 event
listeners. Here, we’ll see how to design interactive visualizations that respond
to mouse click and hover events.
2. We’ll work with the movie ratings dataset, which we previously used when
introducing interactivity in Shiny. The code here makes a static scatterplot for
these data, without implementing any interactivity.
3.  Let’s first consider how to implement a tooltip using hover events. A
tooltip provides “detailed-on-demand” when the user indicates interest in a
specific elements of a visualization. In our application, we’ll display the
movie name whenever the user hovers over a point in the scatterplot. However, in
principle, any pieces of information could be revealed.
4. To implement this type of interactivity, we first listen for anytime the user
hovers over a movie.
5. Next, we create the text that will contain the movie names. Whenever a hover
event occurs, we will need to (i) change the text of the tooltip and (ii) move
the tooltip to the location of the current point.
6. To change the text of the tooltip, we can apply `.text()` to the current data
selection. We move the tooltip using a translation of the parent `div` element.
7. If we want to display much more information about an item using hover events,
it can be useful to link the hovered item with a table.
8. This can be accomplished using a mechanism similar to a tooltip. We again
track hover events and update text in a predefined HTML element (a `<table>` in
this case). In a way, this implementation is even simpler, because we don’t have
to move the text to user’s mouse location.
9. Next, let’s consider click events. Imagine we wanted to allow select movie
genres by clicking elements of the legend, like in the visualization below,
10. To implement this, we’ll use the same array-based logic as in our earlier
select-input-based gapminder visualization. That is, we’ll keep track of an
array of the currently selected genres and we’ll enter and exit datapoints
accordingly each time the array is changed.
11. The main differences are that (i) we need to update the array based on
clicks on the rectangles that form the legend and (ii) when a rectangle is
clicked, we need to update not just the original plot, but also the legend that
defines it.
12. To this end, we bind click listeners to these rectangles. At the start, all
the legend elements are considered selected, and the associated selection array
includes every genre. Whenever a rectangle is clicked, we modify the array,
13. After the array is modified, we then filter the data that defines the
scatterplot,

	exiting scatterplot circles accordingly. We also change the encoding of the
	associated legend rectangle, to let the user know that the associated genre
	has been deselected,
