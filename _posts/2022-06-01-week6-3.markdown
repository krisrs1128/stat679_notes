---
title: Click and Hover Interaction in D3 (Part 3)
layout: post
output:
  md_document:
    preserve_yaml: true
---

1. In our previous notes, we saw how to use hover and click events to define
user interaction in D3 visualizations. In these notes, we’ll consider two
extensions that can lead to more effective interfaces: Voronoi mouseover effects
and click-based graphical queries.
2. Our earlier hover implementations worked, but they could be frustrating to
use, because they require that we place our mouse exactly on top of one of the
scatterplot circles. If the circles were any smaller than they are, interaction
would be essentially impossible.
3. A better strategy is to use a Voronoi mouseover. This is just a fancy way of
saying that we should register a mouseover whenever the mouse moves near to, but
not exactly on, a potential object of interest. Specifically, we will register a
mouse event whenever the nearest neighbor of the mouse’s current position
changes.
4. The main idea is to create a new collection of SVG elements corresponding to
the nearest neighborhoods of the original points. Whenever the mouse moves from
one neighborhood to another, we will register the event.
5. This can be implemented by using D3’s Delauny triangulation library. The code
below finds the nearest neighborhoods of original sample and binds polygons
associated with them. We have bound an event listener to register whenever the
mouse moves from one neighborhood to another.
6. Using the same function as before, we can then update the location of the
tooltip to reflect this mouseover events. The resulting interaction is much
smoother than our previous implementation.
7. Next, let’s consider how to improve click events through graphical queries.
Recall from our Shiny discussion that it can be helpful to define queries using
separate, adjacent visualizations. This increases the information density of a
visualization and minimizes the need for additional interface elements.
8. As a specific example, let’s modify the legend click selection from the
previous notes so that the legend is actually a barchart showing the frequencies
of the different movie types. In this way, the legend has been modified to
encode more information.
9. To implement this change, we create a new dataset and scale associated with
the genre totals. The dataset has this form,

	When we create the rectangles representing the legend elements, we can now use the underlying counts data to adjust the rectangle widths.
