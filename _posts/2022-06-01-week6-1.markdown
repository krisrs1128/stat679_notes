---
title: Types of Interactivity in D3
layout: post
output:
  md_document:
    preserve_yaml: true
---

1. Any HTML page can support text, numeric, button, select, and slider inputs,
just like in Shiny. In fact, behind the scenes, Shiny inputs are simply R
wrappers of plain HTML input elements. For example, the HTML code below creates
an example of each of these inputs.
  ```
  <input type="text"> Enter Something</input>
  <button type="button">Click Me</button>
  <label for="dropdown">Select an option...</label>
  <select name="Select an Option" id="dropdown">
    <option value="optA">Option A</option>
    <option value="optB">Option B</option>
    <option value="optC">Option C</option>
  </select>
  <input type="range" min="0", max="1" step="0.1">This is a slider</input>
  ```
  This is what the page looks like,
  <iframe src="https://krisrs1128.github.io/stat679_code/examples/week6/week6-1/inputs.html"></iframe>
  The default styling for input elements are not that attractive. Fortunately,
  many people have come up with CSS rules to create more attractive components.
  For example, by applying classes defined in Bootstrap (the same library behind
  `bslib`), almost the same HTML code as above yields the page below.
  <iframe src="https://krisrs1128.github.io/stat679_code/examples/week6/week6-1/inputs-bs.html"></iframe>

2. Note that we can define the selection options using a data bind. Contrast this implementation of the gapminder visualization that manually enters the selection options with this alternative that simply binds an array of continent names.
3. In addition to these separate interface elements, we can “listen” for specific kinds of user interactions. In web programming, objects that register specific types of user interactions are called event listeners. Compared to Shiny, D3 has enriched click and brush events. It also has a brand new type of listener which registers hover event.
4. Let’s look at very basics versions of these events on a canvas with just a few randomly located circles.
5. Click events are defined using an `.on(“click”, function)` added to a D3 selection. For example, this will print to the console every time this circle is clicked.
6. If we wanted it to print whenever any of the circles was clicked, we simply add `.on("click", function)` to a selection applying to the full selection.
7. If we just want to detect whether the user’s mouse has moved over an element, we can use `.on("mousemove", function)`. We can keep track of the user’s mouse position using `d3.pointer()`.
8. We can even distinguish between when the mouse has just entered or exited an SVG element using `on("mouseover", function) and `.on(“mouseout”, function)`.
9. Brushes are defined using `d3.brush()`. They can be applied to a group using `.call()` applied to the group (otherwise, they will not appear).
10. We can check for whether the brush has moved by using `.on("brush", )`. Like hover events, we can distinguish between when brushes have been just moved or whether the user has lifted their mouse up. In shiny, we were only able to update a brush selection after the users’ mouse had moved, so this is going to allow us to create smoother visualizations.
11. Finally, we can create multiple brushes simultaneously, which had been impossible in Shiny. This is handy for sketching out complex shapes in time series, as we’ll see in a future lecture.
